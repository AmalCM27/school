"use strict"; (self.webpackChunkfrontend = self.webpackChunkfrontend || []).push([[5834], {
  80316: function (e, t, s) { new (s(56654).Z)("#subjects .swiper", { loop: !0, slidesPerView: 1, spaceBetween: 15, autoplay: { delay: 3e3 }, navigation: { nextEl: "#subjects .swiper-button-next", prevEl: "#subjects .swiper-button-prev" }, pagination: { el: "#subjects .swiper-pagination", clickable: !1 }, breakpoints: { 768: { slidesPerView: 2 }, 1200: { slidesPerView: 3 } } }) }, 56654: function (e, t, s) {
    function a(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function i(e, t) { void 0 === e && (e = {}), void 0 === t && (t = {}), Object.keys(t).forEach((s => { void 0 === e[s] ? e[s] = t[s] : a(t[s]) && a(e[s]) && Object.keys(t[s]).length > 0 && i(e[s], t[s]) })) } function r() { const e = "undefined" != typeof document ? document : {}; return i(e, ht), e } function n() { const e = "undefined" != typeof window ? window : {}; return i(e, ft), e } function l(e) { return void 0 === e && (e = ""), e.trim().split(" ").filter((e => !!e.trim())) } function o(e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) } function d(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function c() { return Date.now() } function p(e) { const t = n(); let s; return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s } function u(e, t) { void 0 === t && (t = "x"); const s = n(); let a, i, r; const l = p(e); return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), r = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (r = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = r.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? r.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? r.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0 } function m(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function h(e) { return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType) } function f() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let s = 1; s < arguments.length; s += 1) { const a = s < 0 || arguments.length <= s ? void 0 : arguments[s]; if (null != a && !h(a)) { const s = Object.keys(Object(a)).filter((e => t.indexOf(e) < 0)); for (let t = 0, i = s.length; t < i; t += 1) { const i = s[t], r = Object.getOwnPropertyDescriptor(a, i); void 0 !== r && r.enumerable && (m(e[i]) && m(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : f(e[i], a[i]) : !m(e[i]) && m(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : f(e[i], a[i])) : e[i] = a[i]) } } } return e } function g(e, t, s) { e.style.setProperty(t, s) } function v(e) { let { swiper: t, targetPosition: s, side: a } = e; const i = n(), r = -t.translate; let l, o = null; const d = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID); const c = s > r ? "next" : "prev", p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, u = () => { l = (new Date).getTime(), null === o && (o = l); const e = Math.max(Math.min((l - o) / d, 1), 0), n = .5 - Math.cos(e * Math.PI) / 2; let c = r + n * (s - r); if (p(c, s) && (c = s), t.wrapperEl.scrollTo({ [a]: c }), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [a]: c }) })), void i.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = i.requestAnimationFrame(u) }; u() } function w(e) { return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e } function b(e, t) { return void 0 === t && (t = ""), [...e.children].filter((e => e.matches(t))) } function y(e) { try { return void console.warn(e) } catch (e) { } } function E(e, t) { void 0 === t && (t = []); const s = document.createElement(e); return s.classList.add(...Array.isArray(t) ? t : l(t)), s } function x(e) { const t = n(), s = r(), a = e.getBoundingClientRect(), i = s.body, l = e.clientTop || i.clientTop || 0, o = e.clientLeft || i.clientLeft || 0, d = e === t ? t.scrollY : e.scrollTop, c = e === t ? t.scrollX : e.scrollLeft; return { top: a.top + d - l, left: a.left + c - o } } function S(e, t) { const s = []; for (; e.previousElementSibling;) { const a = e.previousElementSibling; t ? a.matches(t) && s.push(a) : s.push(a), e = a } return s } function T(e, t) { const s = []; for (; e.nextElementSibling;) { const a = e.nextElementSibling; t ? a.matches(t) && s.push(a) : s.push(a), e = a } return s } function M(e, t) { return n().getComputedStyle(e, null).getPropertyValue(t) } function C(e) { let t, s = e; if (s) { for (t = 0; null !== (s = s.previousSibling);)1 === s.nodeType && (t += 1); return t } } function P(e, t) { const s = []; let a = e.parentElement; for (; a;)t ? a.matches(t) && s.push(a) : s.push(a), a = a.parentElement; return s } function L(e, t) { function s(a) { a.target === e && (t.call(e, a), e.removeEventListener("transitionend", s)) } t && e.addEventListener("transitionend", s) } function A(e, t, s) { const a = n(); return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } function I() { const e = n(), t = r(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } } function k() { return gt || (gt = I()), gt } function z(e) { let { userAgent: t } = void 0 === e ? {} : e; const s = k(), a = n(), i = a.navigator.platform, r = t || a.navigator.userAgent, l = { ios: !1, android: !1 }, o = a.screen.width, d = a.screen.height, c = r.match(/(Android);?[\s\/]+([\d.]+)?/); let p = r.match(/(iPad).*OS\s([\d_]+)/); const u = r.match(/(iPod)(.*OS\s([\d_]+))?/), m = !p && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = "Win32" === i; let f = "MacIntel" === i; const g = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !p && f && s.touch && g.indexOf(`${o}x${d}`) >= 0 && (p = r.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !h && (l.os = "android", l.android = !0), (p || m || u) && (l.os = "ios", l.ios = !0), l } function $(e) { return void 0 === e && (e = {}), vt || (vt = z(e)), vt } function O() { function e() { const e = t.navigator.userAgent.toLowerCase(); return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0 } const t = n(); let s = !1; if (e()) { const e = String(t.navigator.userAgent); if (e.includes("Version/")) { const [t, a] = e.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e))); s = t < 16 || 16 === t && a < 2 } } return { isSafari: s || e(), needPerspectiveFix: s, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent) } } function D() { return wt || (wt = O()), wt } function G(e) { let { swiper: t, on: s, emit: a } = e; const i = n(); let r = null, l = null; const o = () => { t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize")) }, d = () => { t && !t.destroyed && t.initialized && (r = new ResizeObserver((e => { l = i.requestAnimationFrame((() => { const { width: s, height: a } = t; let i = s, r = a; e.forEach((e => { let { contentBoxSize: s, contentRect: a, target: n } = e; n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize) })), i === s && r === a || o() })) })), r.observe(t.el)) }, c = () => { l && i.cancelAnimationFrame(l), r && r.unobserve && t.el && (r.unobserve(t.el), r = null) }, p = () => { t && !t.destroyed && t.initialized && a("orientationchange") }; s("init", (() => { t.params.resizeObserver && void 0 !== i.ResizeObserver ? d() : (i.addEventListener("resize", o), i.addEventListener("orientationchange", p)) })), s("destroy", (() => { c(), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", p) })) } function X(e) { let { swiper: t, extendParams: s, on: a, emit: i } = e; const r = [], l = n(), o = function (e, s) { void 0 === s && (s = {}); const a = new (l.MutationObserver || l.WebkitMutationObserver)((e => { if (t.__preventObserver__) return; if (1 === e.length) return void i("observerUpdate", e[0]); const s = function () { i("observerUpdate", e[0]) }; l.requestAnimationFrame ? l.requestAnimationFrame(s) : l.setTimeout(s, 0) })); a.observe(e, { attributes: void 0 === s.attributes || s.attributes, childList: void 0 === s.childList || s.childList, characterData: void 0 === s.characterData || s.characterData }), r.push(a) }, d = () => { if (t.params.observer) { if (t.params.observeParents) { const e = P(t.hostEl); for (let t = 0; t < e.length; t += 1)o(e[t]) } o(t.hostEl, { childList: t.params.observeSlideChildren }), o(t.wrapperEl, { attributes: !1 }) } }, c = () => { r.forEach((e => { e.disconnect() })), r.splice(0, r.length) }; s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), a("init", d), a("destroy", c) } function H() { const e = this; let t, s; const a = e.el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(M(a, "padding-left") || 0, 10) - parseInt(M(a, "padding-right") || 0, 10), s = s - parseInt(M(a, "padding-top") || 0, 10) - parseInt(M(a, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) } function N() { function e(e, s) { return parseFloat(e.getPropertyValue(t.getDirectionLabel(s)) || 0) } const t = this, s = t.params, { wrapperEl: a, slidesEl: i, size: r, rtlTranslate: n, wrongRTL: l } = t, o = t.virtual && s.virtual.enabled, d = o ? t.virtual.slides.length : t.slides.length, c = b(i, `.${t.params.slideClass}, swiper-slide`), p = o ? t.virtual.slides.length : c.length; let u = []; const m = [], h = []; let f = s.slidesOffsetBefore; "function" == typeof f && (f = s.slidesOffsetBefore.call(t)); let v = s.slidesOffsetAfter; "function" == typeof v && (v = s.slidesOffsetAfter.call(t)); const w = t.snapGrid.length, y = t.slidesGrid.length; let E = s.spaceBetween, x = -f, S = 0, T = 0; if (void 0 === r) return; "string" == typeof E && E.indexOf("%") >= 0 ? E = parseFloat(E.replace("%", "")) / 100 * r : "string" == typeof E && (E = parseFloat(E)), t.virtualSize = -E, c.forEach((e => { n ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" })), s.centeredSlides && s.cssMode && (g(a, "--swiper-centered-offset-before", ""), g(a, "--swiper-centered-offset-after", "")); const C = s.grid && s.grid.rows > 1 && t.grid; let P; C ? t.grid.initSlides(c) : t.grid && t.grid.unsetSlides(); const L = "auto" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter((e => void 0 !== s.breakpoints[e].slidesPerView)).length > 0; for (let a = 0; a < p; a += 1) { let i; if (P = 0, c[a] && (i = c[a]), C && t.grid.updateSlide(a, i, c), !c[a] || "none" !== M(i, "display")) { if ("auto" === s.slidesPerView) { L && (c[a].style[t.getDirectionLabel("width")] = ""); const r = getComputedStyle(i), n = i.style.transform, l = i.style.webkitTransform; if (n && (i.style.transform = "none"), l && (i.style.webkitTransform = "none"), s.roundLengths) P = t.isHorizontal() ? A(i, "width", !0) : A(i, "height", !0); else { const t = e(r, "width"), s = e(r, "padding-left"), a = e(r, "padding-right"), n = e(r, "margin-left"), l = e(r, "margin-right"), o = r.getPropertyValue("box-sizing"); if (o && "border-box" === o) P = t + n + l; else { const { clientWidth: e, offsetWidth: r } = i; P = t + s + a + n + l + (r - e) } } n && (i.style.transform = n), l && (i.style.webkitTransform = l), s.roundLengths && (P = Math.floor(P)) } else P = (r - (s.slidesPerView - 1) * E) / s.slidesPerView, s.roundLengths && (P = Math.floor(P)), c[a] && (c[a].style[t.getDirectionLabel("width")] = `${P}px`); c[a] && (c[a].swiperSlideSize = P), h.push(P), s.centeredSlides ? (x = x + P / 2 + S / 2 + E, 0 === S && 0 !== a && (x = x - r / 2 - E), 0 === a && (x = x - r / 2 - E), Math.abs(x) < .001 && (x = 0), s.roundLengths && (x = Math.floor(x)), T % s.slidesPerGroup == 0 && u.push(x), m.push(x)) : (s.roundLengths && (x = Math.floor(x)), (T - Math.min(t.params.slidesPerGroupSkip, T)) % t.params.slidesPerGroup == 0 && u.push(x), m.push(x), x = x + P + E), t.virtualSize += P + E, S = P, T += 1 } } if (t.virtualSize = Math.max(t.virtualSize, r) + v, n && l && ("slide" === s.effect || "coverflow" === s.effect) && (a.style.width = `${t.virtualSize + E}px`), s.setWrapperSize && (a.style[t.getDirectionLabel("width")] = `${t.virtualSize + E}px`), C && t.grid.updateWrapperSize(P, u), !s.centeredSlides) { const e = []; for (let a = 0; a < u.length; a += 1) { let i = u[a]; s.roundLengths && (i = Math.floor(i)), u[a] <= t.virtualSize - r && e.push(i) } u = e, Math.floor(t.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(t.virtualSize - r) } if (o && s.loop) { const e = h[0] + E; if (s.slidesPerGroup > 1) { const a = Math.ceil((t.virtual.slidesBefore + t.virtual.slidesAfter) / s.slidesPerGroup), i = e * s.slidesPerGroup; for (let e = 0; e < a; e += 1)u.push(u[u.length - 1] + i) } for (let a = 0; a < t.virtual.slidesBefore + t.virtual.slidesAfter; a += 1)1 === s.slidesPerGroup && u.push(u[u.length - 1] + e), m.push(m[m.length - 1] + e), t.virtualSize += e } if (0 === u.length && (u = [0]), 0 !== E) { const e = t.isHorizontal() && n ? "marginLeft" : t.getDirectionLabel("marginRight"); c.filter(((e, t) => !(s.cssMode && !s.loop) || t !== c.length - 1)).forEach((t => { t.style[e] = `${E}px` })) } if (s.centeredSlides && s.centeredSlidesBounds) { let e = 0; h.forEach((t => { e += t + (E || 0) })), e -= E; const t = e - r; u = u.map((e => e <= 0 ? -f : e > t ? t + v : e)) } if (s.centerInsufficientSlides) { let e = 0; if (h.forEach((t => { e += t + (E || 0) })), e -= E, e < r) { const t = (r - e) / 2; u.forEach(((e, s) => { u[s] = e - t })), m.forEach(((e, s) => { m[s] = e + t })) } } if (Object.assign(t, { slides: c, snapGrid: u, slidesGrid: m, slidesSizesGrid: h }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) { g(a, "--swiper-centered-offset-before", -u[0] + "px"), g(a, "--swiper-centered-offset-after", t.size / 2 - h[h.length - 1] / 2 + "px"); const e = -t.snapGrid[0], s = -t.slidesGrid[0]; t.snapGrid = t.snapGrid.map((t => t + e)), t.slidesGrid = t.slidesGrid.map((e => e + s)) } if (p !== d && t.emit("slidesLengthChange"), u.length !== w && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), m.length !== y && t.emit("slidesGridLengthChange"), s.watchSlidesProgress && t.updateSlidesOffset(), t.emit("slidesUpdated"), !(o || s.cssMode || "slide" !== s.effect && "fade" !== s.effect)) { const e = `${s.containerModifierClass}backface-hidden`, a = t.el.classList.contains(e); p <= s.maxBackfaceHiddenSlides ? a || t.el.classList.add(e) : a && t.el.classList.remove(e) } } function B(e) { const t = this, s = [], a = t.virtual && t.params.virtual.enabled; let i, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const n = e => a ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach((e => { s.push(e) })); else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) { const e = t.activeIndex + i; if (e > t.slides.length && !a) break; s.push(n(e)) } else s.push(n(t.activeIndex)); for (i = 0; i < s.length; i += 1)if (void 0 !== s[i]) { const e = s[i].offsetHeight; r = e > r ? e : r } (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`) } function Y() { const e = this, t = e.slides, s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let a = 0; a < t.length; a += 1)t[a].swiperSlideOffset = (e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop) - s - e.cssOverflowAdjustment() } function R(e) { void 0 === e && (e = this && this.translate || 0); const t = this, s = t.params, { slides: a, rtlTranslate: i, snapGrid: r } = t; if (0 === a.length) return; void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e; i && (n = e), a.forEach((e => { e.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass) })), t.visibleSlidesIndexes = [], t.visibleSlides = []; let l = s.spaceBetween; "string" == typeof l && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * t.size : "string" == typeof l && (l = parseFloat(l)); for (let e = 0; e < a.length; e += 1) { const o = a[e]; let d = o.swiperSlideOffset; s.cssMode && s.centeredSlides && (d -= a[0].swiperSlideOffset); const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l), p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l), u = -(n - d), m = u + t.slidesSizesGrid[e], h = u >= 0 && u <= t.size - t.slidesSizesGrid[e]; (u >= 0 && u < t.size - 1 || m > 1 && m <= t.size || u <= 0 && m >= t.size) && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e), a[e].classList.add(s.slideVisibleClass)), h && a[e].classList.add(s.slideFullyVisibleClass), o.progress = i ? -c : c, o.originalProgress = i ? -p : p } } function V(e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * s || 0 } const s = t.params, a = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: r, isEnd: n, progressLoop: l } = t; const o = r, d = n; if (0 === a) i = 0, r = !0, n = !0; else { i = (e - t.minTranslate()) / a; const s = Math.abs(e - t.minTranslate()) < 1, l = Math.abs(e - t.maxTranslate()) < 1; r = s || i <= 0, n = l || i >= 1, s && (i = 0), l && (i = 1) } if (s.loop) { const s = t.getSlideIndexByData(0), a = t.getSlideIndexByData(t.slides.length - 1), i = t.slidesGrid[s], r = t.slidesGrid[a], n = t.slidesGrid[t.slidesGrid.length - 1], o = Math.abs(e); l = o >= i ? (o - i) / n : (o + n - r) / n, l > 1 && (l -= 1) } Object.assign(t, { progress: i, progressLoop: l, isBeginning: r, isEnd: n }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !o && t.emit("reachBeginning toEdge"), n && !d && t.emit("reachEnd toEdge"), (o && !r || d && !n) && t.emit("fromEdge"), t.emit("progress", i) } function q() { const e = this, { slides: t, params: s, slidesEl: a, activeIndex: i } = e, r = e.virtual && s.virtual.enabled, n = e.grid && s.grid && s.grid.rows > 1, l = e => b(a, `.${s.slideClass}${e}, swiper-slide${e}`)[0]; let o, d, c; if (t.forEach((e => { e.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass) })), r) if (s.loop) { let t = i - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = l(`[data-swiper-slide-index="${t}"]`) } else o = l(`[data-swiper-slide-index="${i}"]`); else n ? (o = t.filter((e => e.column === i))[0], c = t.filter((e => e.column === i + 1))[0], d = t.filter((e => e.column === i - 1))[0]) : o = t[i]; o && (o.classList.add(s.slideActiveClass), n ? (c && c.classList.add(s.slideNextClass), d && d.classList.add(s.slidePrevClass)) : (c = T(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && !c && (c = t[0]), c && c.classList.add(s.slideNextClass), d = S(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && 0 === !d && (d = t[t.length - 1]), d && d.classList.add(s.slidePrevClass))), e.emitSlidesClasses() } function _(e) { const { slidesGrid: t, params: s } = e, a = e.rtlTranslate ? e.translate : -e.translate; let i; for (let e = 0; e < t.length; e += 1)void 0 !== t[e + 1] ? a >= t[e] && a < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : a >= t[e] && a < t[e + 1] && (i = e + 1) : a >= t[e] && (i = e); return s.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0), i } function F(e) { const t = this, s = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: a, params: i, activeIndex: r, realIndex: n, snapIndex: l } = t; let o, d = e; const c = e => { let s = e - t.virtual.slidesBefore; return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s }; if (void 0 === d && (d = _(t)), a.indexOf(s) >= 0) o = a.indexOf(s); else { const e = Math.min(i.slidesPerGroupSkip, d); o = e + Math.floor((d - e) / i.slidesPerGroup) } if (o >= a.length && (o = a.length - 1), d === r && !t.params.loop) return void (o !== l && (t.snapIndex = o, t.emit("snapIndexChange"))); if (d === r && t.params.loop && t.virtual && t.params.virtual.enabled) return void (t.realIndex = c(d)); const p = t.grid && i.grid && i.grid.rows > 1; let u; if (t.virtual && i.virtual.enabled && i.loop) u = c(d); else if (p) { const e = t.slides.filter((e => e.column === d))[0]; let s = parseInt(e.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(s) && (s = Math.max(t.slides.indexOf(e), 0)), u = Math.floor(s / i.grid.rows) } else if (t.slides[d]) { const e = t.slides[d].getAttribute("data-swiper-slide-index"); u = e ? parseInt(e, 10) : d } else u = d; Object.assign(t, { previousSnapIndex: l, snapIndex: o, previousRealIndex: n, realIndex: u, previousIndex: r, activeIndex: d }), t.initialized && xt(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (n !== u && t.emit("realIndexChange"), t.emit("slideChange")) } function j(e, t) { const s = this, a = s.params; let i = e.closest(`.${a.slideClass}, swiper-slide`); !i && s.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => { !i && e.matches && e.matches(`.${a.slideClass}, swiper-slide`) && (i = e) })); let r, n = !1; if (i) for (let e = 0; e < s.slides.length; e += 1)if (s.slides[e] === i) { n = !0, r = e; break } if (!i || !n) return s.clickedSlide = void 0, void (s.clickedIndex = void 0); s.clickedSlide = i, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : s.clickedIndex = r, a.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide() } function W(e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const t = this, { params: s, rtlTranslate: a, translate: i, wrapperEl: r } = t; if (s.virtualTranslate) return a ? -i : i; if (s.cssMode) return i; let n = u(r, e); return n += t.cssOverflowAdjustment(), a && (n = -n), n || 0 } function U(e, t) { const s = this, { rtlTranslate: a, params: i, wrapperEl: r, progress: n } = s; let l = 0, o = 0; const d = 0; let c; s.isHorizontal() ? l = a ? -e : e : o = e, i.roundLengths && (l = Math.floor(l), o = Math.floor(o)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? l : o, i.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -l : -o : i.virtualTranslate || (s.isHorizontal() ? l -= s.cssOverflowAdjustment() : o -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${l}px, ${o}px, ${d}px)`); const p = s.maxTranslate() - s.minTranslate(); c = 0 === p ? 0 : (e - s.minTranslate()) / p, c !== n && s.updateProgress(e), s.emit("setTranslate", s.translate, t) } function K() { return -this.snapGrid[0] } function Z() { return -this.snapGrid[this.snapGrid.length - 1] } function Q(e, t, s, a, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0); const r = this, { params: n, wrapperEl: l } = r; if (r.animating && n.preventInteractionOnTransition) return !1; const o = r.minTranslate(), d = r.maxTranslate(); let c; if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) { const e = r.isHorizontal(); if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c; else { if (!r.support.smoothScroll) return v({ swiper: r, targetPosition: -c, side: e ? "left" : "top" }), !0; l.scrollTo({ [e ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd")) }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0 } function J(e, t) { const s = this; s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`, s.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), s.emit("setTransition", e, t) } function ee(e) { let { swiper: t, runCallbacks: s, direction: a, step: i } = e; const { activeIndex: r, previousIndex: n } = t; let l = a; if (l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && r !== n) { if ("reset" === l) return void t.emit(`slideResetTransition${i}`); t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`) } } function te(e, t) { void 0 === e && (e = !0); const s = this, { params: a } = s; a.cssMode || (a.autoHeight && s.updateAutoHeight(), ee({ swiper: s, runCallbacks: e, direction: t, step: "Start" })) } function se(e, t) { void 0 === e && (e = !0); const s = this, { params: a } = s; s.animating = !1, a.cssMode || (s.setTransition(0), ee({ swiper: s, runCallbacks: e, direction: t, step: "End" })) } function ae(e, t, s, a, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e && (e = parseInt(e, 10)); const r = this; let n = e; n < 0 && (n = 0); const { params: l, snapGrid: o, slidesGrid: d, previousIndex: c, activeIndex: p, rtlTranslate: u, wrapperEl: m, enabled: h } = r; if (r.animating && l.preventInteractionOnTransition || !h && !a && !i) return !1; const f = Math.min(r.params.slidesPerGroupSkip, n); let g = f + Math.floor((n - f) / r.params.slidesPerGroup); g >= o.length && (g = o.length - 1); const w = -o[g]; if (l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) { const t = -Math.floor(100 * w), s = Math.floor(100 * d[e]), a = Math.floor(100 * d[e + 1]); void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e) } if (r.initialized && n !== p) { if (!r.allowSlideNext && (u ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate())) return !1; if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n) return !1 } let b; if (n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(w), b = n > p ? "next" : n < p ? "prev" : "reset", u && -w === r.translate || !u && w === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(w), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1; if (l.cssMode) { const e = r.isHorizontal(), s = u ? w : -w; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), t && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { m[e ? "scrollLeft" : "scrollTop"] = s }))) : m[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return v({ swiper: r, targetPosition: s, side: e ? "left" : "top" }), !0; m.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b)) }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0 } function ie(e, t, s, a) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) { e = parseInt(e, 10) } const i = this, r = i.grid && i.params.grid && i.params.grid.rows > 1; let n = e; if (i.params.loop) if (i.virtual && i.params.virtual.enabled) n += i.virtual.slidesBefore; else { let e; if (r) { const t = n * i.params.grid.rows; e = i.slides.filter((e => 1 * e.getAttribute("data-swiper-slide-index") === t))[0].column } else e = i.getSlideIndexByData(n); const t = r ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length, { centeredSlides: s } = i.params; let a = i.params.slidesPerView; "auto" === a ? a = i.slidesPerViewDynamic() : (a = Math.ceil(parseFloat(i.params.slidesPerView, 10)), s && a % 2 == 0 && (a += 1)); let l = t - e < a; if (s && (l = l || e < Math.ceil(a / 2)), l) { const a = s ? e < i.activeIndex ? "prev" : "next" : e - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev"; i.loopFix({ direction: a, slideTo: !0, activeSlideIndex: "next" === a ? e + 1 : e - t + 1, slideRealIndex: "next" === a ? i.realIndex : void 0 }) } if (r) { const e = n * i.params.grid.rows; n = i.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0].column } else n = i.getSlideIndexByData(n) } return requestAnimationFrame((() => { i.slideTo(n, t, s, a) })), i } function re(e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const a = this, { enabled: i, params: r, animating: n } = a; if (!i) return a; let l = r.slidesPerGroup; "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1)); const o = a.activeIndex < r.slidesPerGroupSkip ? 1 : l, d = a.virtual && r.virtual.enabled; if (r.loop) { if (n && !d && r.loopPreventsSliding) return !1; if (a.loopFix({ direction: "next" }), a._clientLeft = a.wrapperEl.clientLeft, a.activeIndex === a.slides.length - 1 && r.cssMode) return requestAnimationFrame((() => { a.slideTo(a.activeIndex + o, e, t, s) })), !0 } return r.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s) } function ne(e, t, s) { function a(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this, { params: r, snapGrid: n, slidesGrid: l, rtlTranslate: o, enabled: d, animating: c } = i; if (!d) return i; const p = i.virtual && r.virtual.enabled; if (r.loop) { if (c && !p && r.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } const u = a(o ? i.translate : -i.translate), m = n.map((e => a(e))); let h = n[m.indexOf(u) - 1]; if (void 0 === h && r.cssMode) { let e; n.forEach(((t, s) => { u >= t && (e = s) })), void 0 !== e && (h = n[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== h && (f = l.indexOf(h), f < 0 && (f = i.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (f = f - i.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), r.rewind && i.isBeginning) { const a = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(a, e, t, s) } return r.loop && 0 === i.activeIndex && r.cssMode ? (requestAnimationFrame((() => { i.slideTo(f, e, t, s) })), !0) : i.slideTo(f, e, t, s) } function le(e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const a = this; return a.slideTo(a.activeIndex, e, t, s) } function oe(e, t, s, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5); const i = this; let r = i.activeIndex; const n = Math.min(i.params.slidesPerGroupSkip, r), l = n + Math.floor((r - n) / i.params.slidesPerGroup), o = i.rtlTranslate ? i.translate : -i.translate; if (o >= i.snapGrid[l]) { const e = i.snapGrid[l]; o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup) } else { const e = i.snapGrid[l - 1]; o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s) } function de() { const e = this, { params: t, slidesEl: s } = e, a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let i, r = e.clickedIndex; const n = e.isElement ? "swiper-slide" : `.${t.slideClass}`; if (t.loop) { if (e.animating) return; i = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = e.getSlideIndex(b(s, `${n}[data-swiper-slide-index="${i}"]`)[0]), d((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = e.getSlideIndex(b(s, `${n}[data-swiper-slide-index="${i}"]`)[0]), d((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } function ce(e) { const t = this, { params: s, slidesEl: a } = t; if (!s.loop || t.virtual && t.params.virtual.enabled) return; const i = () => { b(a, `.${s.slideClass}, swiper-slide`).forEach(((e, t) => { e.setAttribute("data-swiper-slide-index", t) })) }, r = t.grid && s.grid && s.grid.rows > 1, n = s.slidesPerGroup * (r ? s.grid.rows : 1), l = t.slides.length % n != 0, o = r && t.slides.length % s.grid.rows != 0, d = e => { for (let a = 0; a < e; a += 1) { const e = t.isElement ? E("swiper-slide", [s.slideBlankClass]) : E("div", [s.slideClass, s.slideBlankClass]); t.slidesEl.append(e) } }; if (l) { if (s.loopAddBlankSlides) { d(n - t.slides.length % n), t.recalcSlides(), t.updateSlides() } else y("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else if (o) { if (s.loopAddBlankSlides) { d(s.grid.rows - t.slides.length % s.grid.rows), t.recalcSlides(), t.updateSlides() } else y("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else i(); t.loopFix({ slideRealIndex: e, direction: s.centeredSlides ? void 0 : "next" }) } function pe(e) {
      let { slideRealIndex: t, slideTo: s = !0, direction: a, setTranslate: i, activeSlideIndex: r, byController: n, byMousewheel: l } = void 0 === e ? {} : e; const o = this; if (!o.params.loop) return; o.emit("beforeLoopFix"); const { slides: d, allowSlidePrev: c, allowSlideNext: p, slidesEl: u, params: m } = o, { centeredSlides: h } = m; if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && m.virtual.enabled) return s && (m.centeredSlides || 0 !== o.snapIndex ? m.centeredSlides && o.snapIndex < m.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0) : o.slideTo(o.virtual.slides.length, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = p, void o.emit("loopFix"); let f = m.slidesPerView; "auto" === f ? f = o.slidesPerViewDynamic() : (f = Math.ceil(parseFloat(m.slidesPerView, 10)), h && f % 2 == 0 && (f += 1)); const g = m.slidesPerGroupAuto ? f : m.slidesPerGroup; let v = g; v % g != 0 && (v += g - v % g), v += m.loopAdditionalSlides, o.loopedSlides = v; const w = o.grid && m.grid && m.grid.rows > 1; d.length < f + v ? y("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : w && "row" === m.grid.fill && y("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const b = [], E = []; let x = o.activeIndex; void 0 === r ? r = o.getSlideIndex(d.filter((e => e.classList.contains(m.slideActiveClass)))[0]) : x = r; const S = "next" === a || !a, T = "prev" === a || !a; let M = 0, C = 0; const P = w ? Math.ceil(d.length / m.grid.rows) : d.length, L = (w ? d[r].column : r) + (h && void 0 === i ? -f / 2 + .5 : 0); if (L < v) { M = Math.max(v - L, g); for (let e = 0; e < v - L; e += 1) { const t = e - Math.floor(e / P) * P; if (w) { const e = P - t - 1; for (let t = d.length - 1; t >= 0; t -= 1)d[t].column === e && b.push(t) } else b.push(P - t - 1) } } else if (L + f > P - v) { C = Math.max(L - (P - 2 * v), g); for (let e = 0; e < C; e += 1) { const t = e - Math.floor(e / P) * P; w ? d.forEach(((e, s) => { e.column === t && E.push(s) })) : E.push(t) } } if (o.__preventObserver__ = !0, requestAnimationFrame((() => { o.__preventObserver__ = !1 })), T && b.forEach((e => { d[e].swiperLoopMoveDOM = !0, u.prepend(d[e]), d[e].swiperLoopMoveDOM = !1 })), S && E.forEach((e => { d[e].swiperLoopMoveDOM = !0, u.append(d[e]), d[e].swiperLoopMoveDOM = !1 })), o.recalcSlides(), "auto" === m.slidesPerView ? o.updateSlides() : w && (b.length > 0 && T || E.length > 0 && S) && o.slides.forEach(((e, t) => { o.grid.updateSlide(t, e, o.slides) })), m.watchSlidesProgress && o.updateSlidesOffset(), s) if (b.length > 0 && T) {
        if (void 0 === t) {
          const e = o.slidesGrid[x], t = o.slidesGrid[x + M] - e; l ? o.setTranslate(o.translate - t) : (o.slideTo(x + M, 0, !1, !0), i && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - t, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - t))
        } else if (i) { const e = w ? b.length / m.grid.rows : b.length; o.slideTo(o.activeIndex + e, 0, !1, !0), o.touchEventsData.currentTranslate = o.translate }
      } else if (E.length > 0 && S) if (void 0 === t) { const e = o.slidesGrid[x], t = o.slidesGrid[x - C] - e; l ? o.setTranslate(o.translate - t) : (o.slideTo(x - C, 0, !1, !0), i && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - t, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - t)) } else { const e = w ? E.length / m.grid.rows : E.length; o.slideTo(o.activeIndex - e, 0, !1, !0) } if (o.allowSlidePrev = c, o.allowSlideNext = p, o.controller && o.controller.control && !n) { const e = { slideRealIndex: t, direction: a, setTranslate: i, activeSlideIndex: r, byController: !0 }; Array.isArray(o.controller.control) ? o.controller.control.forEach((t => { !t.destroyed && t.params.loop && t.loopFix({ ...e, slideTo: t.params.slidesPerView === m.slidesPerView && s }) })) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix({ ...e, slideTo: o.controller.control.params.slidesPerView === m.slidesPerView && s }) } o.emit("loopFix")
    } function ue() { const e = this, { params: t, slidesEl: s } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const a = []; e.slides.forEach((e => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; a[t] = e })), e.slides.forEach((e => { e.removeAttribute("data-swiper-slide-index") })), a.forEach((e => { s.append(e) })), e.recalcSlides(), e.slideTo(e.realIndex, 0) } function me(e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1 })) } function he() { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1 }))) } function fe(e, t) { function s(t) { if (!t || t === r() || t === n()) return null; t.assignedSlot && (t = t.assignedSlot); const a = t.closest(e); return a || t.getRootNode ? a || s(t.getRootNode().host) : null } return void 0 === t && (t = this), s(t) } function ge(e, t, s) { const a = n(), { params: i } = e, r = i.edgeSwipeDetection, l = i.edgeSwipeThreshold; return !r || !(s <= l || s >= a.innerWidth - l) || "prevent" === r && (t.preventDefault(), !0) } function ve(e) { const t = this, s = r(); let a = e; a.originalEvent && (a = a.originalEvent); const i = t.touchEventsData; if ("pointerdown" === a.type) { if (null !== i.pointerId && i.pointerId !== a.pointerId) return; i.pointerId = a.pointerId } else "touchstart" === a.type && 1 === a.targetTouches.length && (i.touchId = a.targetTouches[0].identifier); if ("touchstart" === a.type) return void ge(t, a, a.targetTouches[0].pageX); const { params: n, touches: l, enabled: o } = t; if (!o) return; if (!n.simulateTouch && "mouse" === a.pointerType) return; if (t.animating && n.preventInteractionOnTransition) return; !t.animating && n.cssMode && n.loop && t.loopFix(); let d = a.target; if ("wrapper" === n.touchEventsTarget && !t.wrapperEl.contains(d)) return; if ("which" in a && 3 === a.which) return; if ("button" in a && a.button > 0) return; if (i.isTouched && i.isMoved) return; const p = !!n.noSwipingClass && "" !== n.noSwipingClass, u = a.composedPath ? a.composedPath() : a.path; p && a.target && a.target.shadowRoot && u && (d = u[0]); const m = n.noSwipingSelector ? n.noSwipingSelector : `.${n.noSwipingClass}`, h = !(!a.target || !a.target.shadowRoot); if (n.noSwiping && (h ? fe(m, d) : d.closest(m))) return void (t.allowClick = !0); if (n.swipeHandler && !d.closest(n.swipeHandler)) return; l.currentX = a.pageX, l.currentY = a.pageY; const f = l.currentX, g = l.currentY; if (!ge(t, a, f)) return; Object.assign(i, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), l.startX = f, l.startY = g, i.touchStartTime = c(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, n.threshold > 0 && (i.allowThresholdMove = !1); let v = !0; d.matches(i.focusableElements) && (v = !1, "SELECT" === d.nodeName && (i.isTouched = !1)), s.activeElement && s.activeElement.matches(i.focusableElements) && s.activeElement !== d && s.activeElement.blur(); const w = v && t.allowTouchMove && n.touchStartPreventDefault; !n.touchStartForcePreventDefault && !w || d.isContentEditable || a.preventDefault(), n.freeMode && n.freeMode.enabled && t.freeMode && t.animating && !n.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", a) } function we(e) { const t = r(), s = this, a = s.touchEventsData, { params: i, touches: n, rtlTranslate: l, enabled: o } = s; if (!o) return; if (!i.simulateTouch && "mouse" === e.pointerType) return; let d, p = e; if (p.originalEvent && (p = p.originalEvent), "pointermove" === p.type) { if (null !== a.touchId) return; if (p.pointerId !== a.pointerId) return } if ("touchmove" === p.type) { if (d = [...p.changedTouches].filter((e => e.identifier === a.touchId))[0], !d || d.identifier !== a.touchId) return } else d = p; if (!a.isTouched) return void (a.startMoving && a.isScrolling && s.emit("touchMoveOpposite", p)); const u = d.pageX, m = d.pageY; if (p.preventedByNestedSwiper) return n.startX = u, void (n.startY = m); if (!s.allowTouchMove) return p.target.matches(a.focusableElements) || (s.allowClick = !1), void (a.isTouched && (Object.assign(n, { startX: u, startY: m, currentX: u, currentY: m }), a.touchStartTime = c())); if (i.touchReleaseOnEdges && !i.loop) if (s.isVertical()) { if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return a.isTouched = !1, void (a.isMoved = !1) } else if (u < n.startX && s.translate <= s.maxTranslate() || u > n.startX && s.translate >= s.minTranslate()) return; if (t.activeElement && p.target === t.activeElement && p.target.matches(a.focusableElements)) return a.isMoved = !0, void (s.allowClick = !1); a.allowTouchCallbacks && s.emit("touchMove", p), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = u, n.currentY = m; const h = n.currentX - n.startX, f = n.currentY - n.startY; if (s.params.threshold && Math.sqrt(h ** 2 + f ** 2) < s.params.threshold) return; if (void 0 === a.isScrolling) { let e; s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? a.isScrolling = !1 : h * h + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(h)) / Math.PI, a.isScrolling = s.isHorizontal() ? e > i.touchAngle : 90 - e > i.touchAngle) } if (a.isScrolling && s.emit("touchMoveOpposite", p), void 0 === a.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (a.startMoving = !0)), a.isScrolling) return void (a.isTouched = !1); if (!a.startMoving) return; s.allowClick = !1, !i.cssMode && p.cancelable && p.preventDefault(), i.touchMoveStopPropagation && !i.nested && p.stopPropagation(); let g = s.isHorizontal() ? h : f, v = s.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY; i.oneWayMovement && (g = Math.abs(g) * (l ? 1 : -1), v = Math.abs(v) * (l ? 1 : -1)), n.diff = g, g *= i.touchRatio, l && (g = -g, v = -v); const w = s.touchesDirection; s.swipeDirection = g > 0 ? "prev" : "next", s.touchesDirection = v > 0 ? "prev" : "next"; const b = s.params.loop && !i.cssMode, y = "next" === s.touchesDirection && s.allowSlideNext || "prev" === s.touchesDirection && s.allowSlidePrev; if (!a.isMoved) { if (b && y && s.loopFix({ direction: s.swipeDirection }), a.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) { const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); s.wrapperEl.dispatchEvent(e) } a.allowMomentumBounce = !1, !i.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", p) } let E; if ((new Date).getTime(), a.isMoved && a.allowThresholdMove && w !== s.touchesDirection && b && y && Math.abs(g) >= 1) return Object.assign(n, { startX: u, startY: m, currentX: u, currentY: m, startTranslate: a.currentTranslate }), a.loopSwapReset = !0, void (a.startTranslate = a.currentTranslate); s.emit("sliderMove", p), a.isMoved = !0, a.currentTranslate = g + a.startTranslate; let x = !0, S = i.resistanceRatio; if (i.touchReleaseOnEdges && (S = 0), g > 0 ? (b && y && !E && a.allowThresholdMove && a.currentTranslate > (i.centeredSlides ? s.minTranslate() - s.slidesSizesGrid[s.activeIndex + 1] : s.minTranslate()) && s.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), a.currentTranslate > s.minTranslate() && (x = !1, i.resistance && (a.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + a.startTranslate + g) ** S))) : g < 0 && (b && y && !E && a.allowThresholdMove && a.currentTranslate < (i.centeredSlides ? s.maxTranslate() + s.slidesSizesGrid[s.slidesSizesGrid.length - 1] : s.maxTranslate()) && s.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: s.slides.length - ("auto" === i.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10))) }), a.currentTranslate < s.maxTranslate() && (x = !1, i.resistance && (a.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - a.startTranslate - g) ** S))), x && (p.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), s.allowSlidePrev || s.allowSlideNext || (a.currentTranslate = a.startTranslate), i.threshold > 0) { if (!(Math.abs(g) > i.threshold || a.allowThresholdMove)) return void (a.currentTranslate = a.startTranslate); if (!a.allowThresholdMove) return a.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, a.currentTranslate = a.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY) } i.followFinger && !i.cssMode && ((i.freeMode && i.freeMode.enabled && s.freeMode || i.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), i.freeMode && i.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(a.currentTranslate), s.setTranslate(a.currentTranslate)) } function be(e) { const t = this, s = t.touchEventsData; let a, i = e; i.originalEvent && (i = i.originalEvent); if ("touchend" === i.type || "touchcancel" === i.type) { if (a = [...i.changedTouches].filter((e => e.identifier === s.touchId))[0], !a || a.identifier !== s.touchId) return } else { if (null !== s.touchId) return; if (i.pointerId !== s.pointerId) return; a = i } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type)) { if (!(["pointercancel", "contextmenu"].includes(i.type) && (t.browser.isSafari || t.browser.isWebView))) return } s.pointerId = null, s.touchId = null; const { params: r, touches: n, rtlTranslate: l, slidesGrid: o, enabled: p } = t; if (!p) return; if (!r.simulateTouch && "mouse" === i.pointerType) return; if (s.allowTouchCallbacks && t.emit("touchEnd", i), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && r.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1); r.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const u = c(), m = u - s.touchStartTime; if (t.allowClick) { const e = i.path || i.composedPath && i.composedPath(); t.updateClickedSlide(e && e[0] || i.target, e), t.emit("tap click", i), m < 300 && u - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", i) } if (s.lastClickTime = c(), d((() => { t.destroyed || (t.allowClick = !0) })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === n.diff && !s.loopSwapReset || s.currentTranslate === s.startTranslate && !s.loopSwapReset) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1); let h; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = r.followFinger ? l ? t.translate : -t.translate : -s.currentTranslate, r.cssMode) return; if (r.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); const f = h >= -t.maxTranslate() && !t.params.loop; let g = 0, v = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const t = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; void 0 !== o[e + t] ? (f || h >= o[e] && h < o[e + t]) && (g = e, v = o[e + t] - o[e]) : (f || h >= o[e]) && (g = e, v = o[o.length - 1] - o[o.length - 2]) } let w = null, b = null; r.rewind && (t.isBeginning ? b = r.virtual && r.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (w = 0)); const y = (h - o[g]) / v, E = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (m > r.longSwipesMs) { if (!r.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? w : g + E) : t.slideTo(g)), "prev" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(g + E) : null !== b && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(b) : t.slideTo(g)) } else { if (!r.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (i.target === t.navigation.nextEl || i.target === t.navigation.prevEl) ? i.target === t.navigation.nextEl ? t.slideTo(g + E) : t.slideTo(g) : ("next" === t.swipeDirection && t.slideTo(null !== w ? w : g + E), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g)) } } function ye() { const e = this, { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: a, allowSlidePrev: i, snapGrid: r } = e, n = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const l = n && t.loop; !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || l ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }), 500)), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function Ee(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function xe() { const e = this, { wrapperEl: t, rtlTranslate: s, enabled: a } = e; if (!a) return; let i; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function Se(e) { const t = this; yt(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update() } function Te() { const e = this; e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto")) } function Me() { const e = this, { params: t } = e; e.onTouchStart = ve.bind(e), e.onTouchMove = we.bind(e), e.onTouchEnd = be.bind(e), e.onDocumentTouchStart = Te.bind(e), t.cssMode && (e.onScroll = xe.bind(e)), e.onClick = Ee.bind(e), e.onLoad = Se.bind(e), St(e, "on") } function Ce() { St(this, "off") } function Pe() { const e = this, { realIndex: t, initialized: s, params: a, el: i } = e, r = a.breakpoints; if (!r || r && 0 === Object.keys(r).length) return; const n = e.getBreakpoint(r, e.params.breakpointsBase, e.el); if (!n || e.currentBreakpoint === n) return; const l = (n in r ? r[n] : void 0) || e.originalParams, o = Tt(e, a), d = Tt(e, l), c = a.enabled; o && !d ? (i.classList.remove(`${a.containerModifierClass}grid`, `${a.containerModifierClass}grid-column`), e.emitContainerClasses()) : !o && d && (i.classList.add(`${a.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === a.grid.fill) && i.classList.add(`${a.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { if (void 0 === l[t]) return; const s = a[t] && a[t].enabled, i = l[t] && l[t].enabled; s && !i && e[t].disable(), !s && i && e[t].enable() })); const p = l.direction && l.direction !== a.direction, u = a.loop && (l.slidesPerView !== a.slidesPerView || p), m = a.loop; p && s && e.changeDirection(), f(e.params, l); const h = e.params.enabled, g = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), c && !h ? e.disable() : !c && h && e.enable(), e.currentBreakpoint = n, e.emit("_beforeBreakpoint", l), s && (u ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !m && g ? (e.loopCreate(t), e.updateSlides()) : m && !g && e.loopDestroy()), e.emit("breakpoint", l) } function Le(e, t, s) { if (void 0 === t && (t = "window"), !e || "container" === t && !s) return; let a = !1; const i = n(), r = "window" === t ? i.innerHeight : s.clientHeight, l = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: r * t, point: e } } return { value: e, point: e } })); l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < l.length; e += 1) { const { point: r, value: n } = l[e]; "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r) } return a || "max" } function Ae(e, t) { const s = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((a => { e[a] && s.push(t + a) })) : "string" == typeof e && s.push(t + e) })), s } function Ie() { const e = this, { classNames: t, params: s, rtl: a, el: i, device: r } = e, n = Ae(["initialized", s.direction, { "free-mode": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: a }, { grid: s.grid && s.grid.rows > 1 }, { "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": s.cssMode }, { centered: s.cssMode && s.centeredSlides }, { "watch-progress": s.watchSlidesProgress }], s.containerModifierClass); t.push(...n), i.classList.add(...t), e.emitContainerClasses() } function ke() { const e = this, { el: t, classNames: s } = e; t.classList.remove(...s), e.emitContainerClasses() } function ze() { const e = this, { isLocked: t, params: s } = e, { slidesOffsetBefore: a } = s; if (a) { const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a; e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length; !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } function $e(e, t) { return function (s) { void 0 === s && (s = {}); const a = Object.keys(s)[0], i = s[a]; "object" == typeof i && null !== i ? (!0 === e[a] && (e[a] = { enabled: !0 }), "navigation" === a && e[a] && e[a].enabled && !e[a].prevEl && !e[a].nextEl && (e[a].auto = !0), ["pagination", "scrollbar"].indexOf(a) >= 0 && e[a] && e[a].enabled && !e[a].el && (e[a].auto = !0), a in e && "enabled" in i ? ("object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = { enabled: !1 }), f(t, s)) : f(t, s)) : f(t, s) } } function Oe(e) { function t(e, t) { const s = d.params.virtual; if (s.cache && d.virtual.cache[t]) return d.virtual.cache[t]; let a; return s.renderSlide ? (a = s.renderSlide.call(d, e, t), "string" == typeof a && (h.innerHTML = a, a = h.children[0])) : a = d.isElement ? E("swiper-slide") : E("div", d.params.slideClass), a.setAttribute("data-swiper-slide-index", t), s.renderSlide || (a.innerHTML = e), s.cache && (d.virtual.cache[t] = a), a } function s(e) { function s() { d.updateSlides(), d.updateProgress(), d.updateSlidesClasses(), u("virtualUpdate") } const { slidesPerView: a, slidesPerGroup: i, centeredSlides: r, loop: n } = d.params, { addSlidesBefore: l, addSlidesAfter: o } = d.params.virtual, { from: c, to: p, slides: m, slidesGrid: h, offset: f } = d.virtual; d.params.cssMode || d.updateActiveIndex(); const g = d.activeIndex || 0; let v, w, y; v = d.rtlTranslate ? "right" : d.isHorizontal() ? "left" : "top", r ? (w = Math.floor(a / 2) + i + o, y = Math.floor(a / 2) + i + l) : (w = a + (i - 1) + o, y = (n ? a : i) + l); let E = g - y, x = g + w; n || (E = Math.max(E, 0), x = Math.min(x, m.length - 1)); let S = (d.slidesGrid[E] || 0) - (d.slidesGrid[0] || 0); if (n && g >= y ? (E -= y, r || (S += d.slidesGrid[0])) : n && g < y && (E = -y, r && (S += d.slidesGrid[0])), Object.assign(d.virtual, { from: E, to: x, offset: S, slidesGrid: d.slidesGrid, slidesBefore: y, slidesAfter: w }), c === E && p === x && !e) return d.slidesGrid !== h && S !== f && d.slides.forEach((e => { e.style[v] = S - Math.abs(d.cssOverflowAdjustment()) + "px" })), d.updateProgress(), void u("virtualUpdate"); if (d.params.virtual.renderExternal) return d.params.virtual.renderExternal.call(d, { offset: S, from: E, to: x, slides: function () { const e = []; for (let t = E; t <= x; t += 1)e.push(m[t]); return e }() }), void (d.params.virtual.renderExternalUpdate ? s() : u("virtualUpdate")); const T = [], M = [], C = e => { let t = e; return e < 0 ? t = m.length + e : t >= m.length && (t -= m.length), t }; if (e) d.slides.filter((e => e.matches(`.${d.params.slideClass}, swiper-slide`))).forEach((e => { e.remove() })); else for (let e = c; e <= p; e += 1)if (e < E || e > x) { const t = C(e); d.slides.filter((e => e.matches(`.${d.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`))).forEach((e => { e.remove() })) } const P = n ? -m.length : 0, L = n ? 2 * m.length : m.length; for (let t = P; t < L; t += 1)if (t >= E && t <= x) { const s = C(t); void 0 === p || e ? M.push(s) : (t > p && M.push(s), t < c && T.push(s)) } if (M.forEach((e => { d.slidesEl.append(t(m[e], e)) })), n) for (let e = T.length - 1; e >= 0; e -= 1) { const s = T[e]; d.slidesEl.prepend(t(m[s], s)) } else T.sort(((e, t) => t - e)), T.forEach((e => { d.slidesEl.prepend(t(m[e], e)) })); b(d.slidesEl, ".swiper-slide, swiper-slide").forEach((e => { e.style[v] = S - Math.abs(d.cssOverflowAdjustment()) + "px" })), s() } function a(e) { if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && d.virtual.slides.push(e[t]); else d.virtual.slides.push(e); s(!0) } function i(e) { const t = d.activeIndex; let a = t + 1, i = 1; if (Array.isArray(e)) { for (let t = 0; t < e.length; t += 1)e[t] && d.virtual.slides.unshift(e[t]); a = t + e.length, i = e.length } else d.virtual.slides.unshift(e); if (d.params.virtual.cache) { const e = d.virtual.cache, t = {}; Object.keys(e).forEach((s => { const a = e[s], r = a.getAttribute("data-swiper-slide-index"); r && a.setAttribute("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a })), d.virtual.cache = t } s(!0), d.slideTo(a, 0) } function n(e) { if (null == e) return; let t = d.activeIndex; if (Array.isArray(e)) for (let s = e.length - 1; s >= 0; s -= 1)d.params.virtual.cache && (delete d.virtual.cache[e[s]], Object.keys(d.virtual.cache).forEach((t => { t > e && (d.virtual.cache[t - 1] = d.virtual.cache[t], d.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete d.virtual.cache[t]) }))), d.virtual.slides.splice(e[s], 1), e[s] < t && (t -= 1), t = Math.max(t, 0); else d.params.virtual.cache && (delete d.virtual.cache[e], Object.keys(d.virtual.cache).forEach((t => { t > e && (d.virtual.cache[t - 1] = d.virtual.cache[t], d.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete d.virtual.cache[t]) }))), d.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0); s(!0), d.slideTo(t, 0) } function l() { d.virtual.slides = [], d.params.virtual.cache && (d.virtual.cache = {}), s(!0), d.slideTo(0, 0) } let o, { swiper: d, extendParams: c, on: p, emit: u } = e; c({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); const m = r(); d.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const h = m.createElement("div"); p("beforeInit", (() => { if (!d.params.virtual.enabled) return; let e; if (void 0 === d.passedParams.virtual.slides) { const t = [...d.slidesEl.children].filter((e => e.matches(`.${d.params.slideClass}, swiper-slide`))); t && t.length && (d.virtual.slides = [...t], e = !0, t.forEach(((e, t) => { e.setAttribute("data-swiper-slide-index", t), d.virtual.cache[t] = e, e.remove() }))) } e || (d.virtual.slides = d.params.virtual.slides), d.classNames.push(`${d.params.containerModifierClass}virtual`), d.params.watchSlidesProgress = !0, d.originalParams.watchSlidesProgress = !0, s() })), p("setTranslate", (() => { d.params.virtual.enabled && (d.params.cssMode && !d._immediateVirtual ? (clearTimeout(o), o = setTimeout((() => { s() }), 100)) : s()) })), p("init update resize", (() => { d.params.virtual.enabled && d.params.cssMode && g(d.wrapperEl, "--swiper-virtual-size", `${d.virtualSize}px`) })), Object.assign(d.virtual, { appendSlide: a, prependSlide: i, removeSlide: n, removeAllSlides: l, update: s }) } function De(e) { function t(e) { if (!i.enabled) return; const { rtlTranslate: t } = i; let s = e; s.originalEvent && (s = s.originalEvent); const a = s.keyCode || s.charCode, r = i.params.keyboard.pageUpDown, n = r && 33 === a, l = r && 34 === a, o = 37 === a, u = 39 === a, m = 38 === a, h = 40 === a; if (!i.allowSlideNext && (i.isHorizontal() && u || i.isVertical() && h || l)) return !1; if (!i.allowSlidePrev && (i.isHorizontal() && o || i.isVertical() && m || n)) return !1; if (!(s.shiftKey || s.altKey || s.ctrlKey || s.metaKey || c.activeElement && c.activeElement.nodeName && ("input" === c.activeElement.nodeName.toLowerCase() || "textarea" === c.activeElement.nodeName.toLowerCase()))) { if (i.params.keyboard.onlyInViewport && (n || l || o || u || m || h)) { let e = !1; if (P(i.el, `.${i.params.slideClass}, swiper-slide`).length > 0 && 0 === P(i.el, `.${i.params.slideActiveClass}`).length) return; const s = i.el, a = s.clientWidth, r = s.clientHeight, n = p.innerWidth, l = p.innerHeight, o = x(s); t && (o.left -= s.scrollLeft); const d = [[o.left, o.top], [o.left + a, o.top], [o.left, o.top + r], [o.left + a, o.top + r]]; for (let t = 0; t < d.length; t += 1) { const s = d[t]; if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) { if (0 === s[0] && 0 === s[1]) continue; e = !0 } } if (!e) return } i.isHorizontal() ? ((n || l || o || u) && (s.preventDefault ? s.preventDefault() : s.returnValue = !1), ((l || u) && !t || (n || o) && t) && i.slideNext(), ((n || o) && !t || (l || u) && t) && i.slidePrev()) : ((n || l || m || h) && (s.preventDefault ? s.preventDefault() : s.returnValue = !1), (l || h) && i.slideNext(), (n || m) && i.slidePrev()), d("keyPress", a) } } function s() { i.keyboard.enabled || (c.addEventListener("keydown", t), i.keyboard.enabled = !0) } function a() { i.keyboard.enabled && (c.removeEventListener("keydown", t), i.keyboard.enabled = !1) } let { swiper: i, extendParams: l, on: o, emit: d } = e; const c = r(), p = n(); i.keyboard = { enabled: !1 }, l({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), o("init", (() => { i.params.keyboard.enabled && s() })), o("destroy", (() => { i.keyboard.enabled && a() })), Object.assign(i.keyboard, { enable: s, disable: a }) } function Ge(e) { function t(e) { const t = 10, s = 40, a = 800; let i = 0, r = 0, n = 0, l = 0; return "detail" in e && (r = e.detail), "wheelDelta" in e && (r = -e.wheelDelta / 120), "wheelDeltaY" in e && (r = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (i = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (i = r, r = 0), n = i * t, l = r * t, "deltaY" in e && (l = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = l, l = 0), (n || l) && e.deltaMode && (1 === e.deltaMode ? (n *= s, l *= s) : (n *= a, l *= a)), n && !i && (i = n < 1 ? -1 : 1), l && !r && (r = l < 1 ? -1 : 1), { spinX: i, spinY: r, pixelX: n, pixelY: l } } function s() { m.enabled && (m.mouseEntered = !0) } function a() { m.enabled && (m.mouseEntered = !1) } function i(e) { return !(m.params.mousewheel.thresholdDelta && e.delta < m.params.mousewheel.thresholdDelta) && (!(m.params.mousewheel.thresholdTime && c() - y < m.params.mousewheel.thresholdTime) && (e.delta >= 6 && c() - y < 60 || (e.direction < 0 ? m.isEnd && !m.params.loop || m.animating || (m.slideNext(), g("scroll", e.raw)) : m.isBeginning && !m.params.loop || m.animating || (m.slidePrev(), g("scroll", e.raw)), y = (new v.Date).getTime(), !1))) } function r(e) { const t = m.params.mousewheel; if (e.direction < 0) { if (m.isEnd && !m.params.loop && t.releaseOnEdges) return !0 } else if (m.isBeginning && !m.params.loop && t.releaseOnEdges) return !0; return !1 } function l(e) { let s = e, a = !0; if (!m.enabled) return; if (e.target.closest(`.${m.params.mousewheel.noMousewheelClass}`)) return; const n = m.params.mousewheel; m.params.cssMode && s.preventDefault(); let l = m.el; "container" !== m.params.mousewheel.eventsTarget && (l = document.querySelector(m.params.mousewheel.eventsTarget)); const o = l && l.contains(s.target); if (!m.mouseEntered && !o && !n.releaseOnEdges) return !0; s.originalEvent && (s = s.originalEvent); let p = 0; const u = m.rtlTranslate ? -1 : 1, h = t(s); if (n.forceToAxis) if (m.isHorizontal()) { if (!(Math.abs(h.pixelX) > Math.abs(h.pixelY))) return !0; p = -h.pixelX * u } else { if (!(Math.abs(h.pixelY) > Math.abs(h.pixelX))) return !0; p = -h.pixelY } else p = Math.abs(h.pixelX) > Math.abs(h.pixelY) ? -h.pixelX * u : -h.pixelY; if (0 === p) return !0; n.invert && (p = -p); let f = m.getTranslate() + p * n.sensitivity; if (f >= m.minTranslate() && (f = m.minTranslate()), f <= m.maxTranslate() && (f = m.maxTranslate()), a = !!m.params.loop || !(f === m.minTranslate() || f === m.maxTranslate()), a && m.params.nested && s.stopPropagation(), m.params.freeMode && m.params.freeMode.enabled) { const e = { time: c(), delta: Math.abs(p), direction: Math.sign(p) }, t = b && e.time < b.time + 500 && e.delta <= b.delta && e.direction === b.direction; if (!t) { b = void 0; let a = m.getTranslate() + p * n.sensitivity; const i = m.isBeginning, r = m.isEnd; if (a >= m.minTranslate() && (a = m.minTranslate()), a <= m.maxTranslate() && (a = m.maxTranslate()), m.setTransition(0), m.setTranslate(a), m.updateProgress(), m.updateActiveIndex(), m.updateSlidesClasses(), (!i && m.isBeginning || !r && m.isEnd) && m.updateSlidesClasses(), m.params.loop && m.loopFix({ direction: e.direction < 0 ? "next" : "prev", byMousewheel: !0 }), m.params.freeMode.sticky) { clearTimeout(w), w = void 0, E.length >= 15 && E.shift(); const t = E.length ? E[E.length - 1] : void 0, s = E[0]; if (E.push(e), t && (e.delta > t.delta || e.direction !== t.direction)) E.splice(0); else if (E.length >= 15 && e.time - s.time < 500 && s.delta - e.delta >= 1 && e.delta <= 6) { const t = p > 0 ? .8 : .2; b = e, E.splice(0), w = d((() => { m.slideToClosest(m.params.speed, !0, void 0, t) }), 0) } w || (w = d((() => { const t = .5; b = e, E.splice(0), m.slideToClosest(m.params.speed, !0, void 0, t) }), 500)) } if (t || g("scroll", s), m.params.autoplay && m.params.autoplayDisableOnInteraction && m.autoplay.stop(), n.releaseOnEdges && (a === m.minTranslate() || a === m.maxTranslate())) return !0 } } else { const t = { time: c(), delta: Math.abs(p), direction: Math.sign(p), raw: e }; E.length >= 2 && E.shift(); const s = E.length ? E[E.length - 1] : void 0; if (E.push(t), s ? (t.direction !== s.direction || t.delta > s.delta || t.time > s.time + 150) && i(t) : i(t), r(t)) return !0 } return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1 } function o(e) { let t = m.el; "container" !== m.params.mousewheel.eventsTarget && (t = document.querySelector(m.params.mousewheel.eventsTarget)), t[e]("mouseenter", s), t[e]("mouseleave", a), t[e]("wheel", l) } function p() { return m.params.cssMode ? (m.wrapperEl.removeEventListener("wheel", l), !0) : !m.mousewheel.enabled && (o("addEventListener"), m.mousewheel.enabled = !0, !0) } function u() { return m.params.cssMode ? (m.wrapperEl.addEventListener(event, l), !0) : !!m.mousewheel.enabled && (o("removeEventListener"), m.mousewheel.enabled = !1, !0) } let { swiper: m, extendParams: h, on: f, emit: g } = e; const v = n(); let w; h({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null, noMousewheelClass: "swiper-no-mousewheel" } }), m.mousewheel = { enabled: !1 }; let b, y = c(); const E = []; f("init", (() => { !m.params.mousewheel.enabled && m.params.cssMode && u(), m.params.mousewheel.enabled && p() })), f("destroy", (() => { m.params.cssMode && p(), m.mousewheel.enabled && u() })), Object.assign(m.mousewheel, { enable: p, disable: u }) } function Xe(e, t, s, a) { return e.params.createElements && Object.keys(a).forEach((i => { if (!s[i] && !0 === s.auto) { let r = b(e.el, `.${a[i]}`)[0]; r || (r = E("div", a[i]), r.className = a[i], e.el.append(r)), s[i] = r, t[i] = r } })), s } function He(e) {
      function t(e) { let t; return e && "string" == typeof e && o.isElement && (t = o.el.querySelector(e), t) ? t : (e && ("string" == typeof e && (t = [...document.querySelectorAll(e)]), o.params.uniqueNavElements && "string" == typeof e && t.length > 1 && 1 === o.el.querySelectorAll(e).length && (t = o.el.querySelector(e))), e && !t ? e : t) } function s(e, t) { const s = o.params.navigation; (e = u(e)).forEach((e => { e && (e.classList[t ? "add" : "remove"](...s.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = t), o.params.watchOverflow && o.enabled && e.classList[o.isLocked ? "add" : "remove"](s.lockClass)) })) } function a() { const { nextEl: e, prevEl: t } = o.navigation; if (o.params.loop) return s(t, !1), void s(e, !1); s(t, o.isBeginning && !o.params.rewind), s(e, o.isEnd && !o.params.rewind) } function i(e) { e.preventDefault(), (!o.isBeginning || o.params.loop || o.params.rewind) && (o.slidePrev(), p("navigationPrev")) } function r(e) { e.preventDefault(), (!o.isEnd || o.params.loop || o.params.rewind) && (o.slideNext(), p("navigationNext")) } function n() { const e = o.params.navigation; if (o.params.navigation = Xe(o, o.originalParams.navigation, o.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; let s = t(e.nextEl), a = t(e.prevEl); Object.assign(o.navigation, { nextEl: s, prevEl: a }), s = u(s), a = u(a); const n = (t, s) => { t && t.addEventListener("click", "next" === s ? r : i), !o.enabled && t && t.classList.add(...e.lockClass.split(" ")) }; s.forEach((e => n(e, "next"))), a.forEach((e => n(e, "prev"))) } function l() { let { nextEl: e, prevEl: t } = o.navigation; e = u(e), t = u(t); const s = (e, t) => { e.removeEventListener("click", "next" === t ? r : i), e.classList.remove(...o.params.navigation.disabledClass.split(" ")) }; e.forEach((e => s(e, "next"))), t.forEach((e => s(e, "prev"))) } let { swiper: o, extendParams: d, on: c, emit: p } = e; d({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), o.navigation = { nextEl: null, prevEl: null }; const u = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)); c("init", (() => { !1 === o.params.navigation.enabled ? h() : (n(), a()) })), c("toEdge fromEdge lock unlock", (() => { a() })), c("destroy", (() => { l() })), c("enable disable", (() => { let { nextEl: e, prevEl: t } = o.navigation; e = u(e), t = u(t), o.enabled ? a() : [...e, ...t].filter((e => !!e)).forEach((e => e.classList.add(o.params.navigation.lockClass))) })), c("click", ((e, t) => { let { nextEl: s, prevEl: a } = o.navigation; s = u(s), a = u(a); const i = t.target; if (o.params.navigation.hideOnClick && !a.includes(i) && !s.includes(i)) { if (o.pagination && o.params.pagination && o.params.pagination.clickable && (o.pagination.el === i || o.pagination.el.contains(i))) return; let e; s.length ? e = s[0].classList.contains(o.params.navigation.hiddenClass) : a.length && (e = a[0].classList.contains(o.params.navigation.hiddenClass)), p(!0 === e ? "navigationShow" : "navigationHide"), [...s, ...a].filter((e => !!e)).forEach((e => e.classList.toggle(o.params.navigation.hiddenClass))) } }))
        ; const m = () => { o.el.classList.remove(...o.params.navigation.navigationDisabledClass.split(" ")), n(), a() }, h = () => { o.el.classList.add(...o.params.navigation.navigationDisabledClass.split(" ")), l() }; Object.assign(o.navigation, { enable: m, disable: h, update: a, init: n, destroy: l })
    } function Ne(e) { return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function Be(e) { function t() { return !o.params.pagination.el || !o.pagination.el || Array.isArray(o.pagination.el) && 0 === o.pagination.el.length } function s(e, t) { const { bulletActiveClass: s } = o.params.pagination; e && (e = e[("prev" === t ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${s}-${t}`), (e = e[("prev" === t ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${s}-${t}-${t}`)) } function a(e) { const t = e.target.closest(Ne(o.params.pagination.bulletClass)); if (!t) return; e.preventDefault(); const s = C(t) * o.params.slidesPerGroup; if (o.params.loop) { if (o.realIndex === s) return; o.slideToLoop(s) } else o.slideTo(s) } function i() { const e = o.rtl, a = o.params.pagination; if (t()) return; let i, r, n = o.pagination.el; n = f(n); const l = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : o.slides.length, d = o.params.loop ? Math.ceil(l / o.params.slidesPerGroup) : o.snapGrid.length; if (o.params.loop ? (r = o.previousRealIndex || 0, i = o.params.slidesPerGroup > 1 ? Math.floor(o.realIndex / o.params.slidesPerGroup) : o.realIndex) : void 0 !== o.snapIndex ? (i = o.snapIndex, r = o.previousSnapIndex) : (r = o.previousIndex || 0, i = o.activeIndex || 0), "bullets" === a.type && o.pagination.bullets && o.pagination.bullets.length > 0) { const t = o.pagination.bullets; let l, d, c; if (a.dynamicBullets && (m = A(t[0], o.isHorizontal() ? "width" : "height", !0), n.forEach((e => { e.style[o.isHorizontal() ? "width" : "height"] = m * (a.dynamicMainBullets + 4) + "px" })), a.dynamicMainBullets > 1 && void 0 !== r && (h += i - (r || 0), h > a.dynamicMainBullets - 1 ? h = a.dynamicMainBullets - 1 : h < 0 && (h = 0)), l = Math.max(i - h, 0), d = l + (Math.min(t.length, a.dynamicMainBullets) - 1), c = (d + l) / 2), t.forEach((e => { const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${a.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat(); e.classList.remove(...t) })), n.length > 1) t.forEach((e => { const t = C(e); t === i ? e.classList.add(...a.bulletActiveClass.split(" ")) : o.isElement && e.setAttribute("part", "bullet"), a.dynamicBullets && (t >= l && t <= d && e.classList.add(...`${a.bulletActiveClass}-main`.split(" ")), t === l && s(e, "prev"), t === d && s(e, "next")) })); else { const e = t[i]; if (e && e.classList.add(...a.bulletActiveClass.split(" ")), o.isElement && t.forEach(((e, t) => { e.setAttribute("part", t === i ? "bullet-active" : "bullet") })), a.dynamicBullets) { const e = t[l], i = t[d]; for (let e = l; e <= d; e += 1)t[e] && t[e].classList.add(...`${a.bulletActiveClass}-main`.split(" ")); s(e, "prev"), s(i, "next") } } if (a.dynamicBullets) { const s = Math.min(t.length, a.dynamicMainBullets + 4), i = (m * s - m) / 2 - c * m, r = e ? "right" : "left"; t.forEach((e => { e.style[o.isHorizontal() ? r : "top"] = `${i}px` })) } } n.forEach(((e, t) => { if ("fraction" === a.type && (e.querySelectorAll(Ne(a.currentClass)).forEach((e => { e.textContent = a.formatFractionCurrent(i + 1) })), e.querySelectorAll(Ne(a.totalClass)).forEach((e => { e.textContent = a.formatFractionTotal(d) }))), "progressbar" === a.type) { let t; t = a.progressbarOpposite ? o.isHorizontal() ? "vertical" : "horizontal" : o.isHorizontal() ? "horizontal" : "vertical"; const s = (i + 1) / d; let r = 1, n = 1; "horizontal" === t ? r = s : n = s, e.querySelectorAll(Ne(a.progressbarFillClass)).forEach((e => { e.style.transform = `translate3d(0,0,0) scaleX(${r}) scaleY(${n})`, e.style.transitionDuration = `${o.params.speed}ms` })) } "custom" === a.type && a.renderCustom ? (e.innerHTML = a.renderCustom(o, i + 1, d), 0 === t && p("paginationRender", e)) : (0 === t && p("paginationRender", e), p("paginationUpdate", e)), o.params.watchOverflow && o.enabled && e.classList[o.isLocked ? "add" : "remove"](a.lockClass) })) } function r() { const e = o.params.pagination; if (t()) return; const s = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : o.grid && o.params.grid.rows > 1 ? o.slides.length / Math.ceil(o.params.grid.rows) : o.slides.length; let a = o.pagination.el; a = f(a); let i = ""; if ("bullets" === e.type) { let t = o.params.loop ? Math.ceil(s / o.params.slidesPerGroup) : o.snapGrid.length; o.params.freeMode && o.params.freeMode.enabled && t > s && (t = s); for (let s = 0; s < t; s += 1)e.renderBullet ? i += e.renderBullet.call(o, s, e.bulletClass) : i += `<${e.bulletElement} ${o.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>` } "fraction" === e.type && (i = e.renderFraction ? e.renderFraction.call(o, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (i = e.renderProgressbar ? e.renderProgressbar.call(o, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), o.pagination.bullets = [], a.forEach((t => { "custom" !== e.type && (t.innerHTML = i || ""), "bullets" === e.type && o.pagination.bullets.push(...t.querySelectorAll(Ne(e.bulletClass))) })), "custom" !== e.type && p("paginationRender", a[0]) } function n() { o.params.pagination = Xe(o, o.originalParams.pagination, o.params.pagination, { el: "swiper-pagination" }); const e = o.params.pagination; if (!e.el) return; let t; "string" == typeof e.el && o.isElement && (t = o.el.querySelector(e.el)), t || "string" != typeof e.el || (t = [...document.querySelectorAll(e.el)]), t || (t = e.el), t && 0 !== t.length && (o.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(t) && t.length > 1 && (t = [...o.el.querySelectorAll(e.el)], t.length > 1 && (t = t.filter((e => P(e, ".swiper")[0] === o.el))[0])), Array.isArray(t) && 1 === t.length && (t = t[0]), Object.assign(o.pagination, { el: t }), t = f(t), t.forEach((t => { "bullets" === e.type && e.clickable && t.classList.add(...(e.clickableClass || "").split(" ")), t.classList.add(e.modifierClass + e.type), t.classList.add(o.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (t.classList.add(`${e.modifierClass}${e.type}-dynamic`), h = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && t.classList.add(e.progressbarOppositeClass), e.clickable && t.addEventListener("click", a), o.enabled || t.classList.add(e.lockClass) }))) } function l() { const e = o.params.pagination; if (t()) return; let s = o.pagination.el; s && (s = f(s), s.forEach((t => { t.classList.remove(e.hiddenClass), t.classList.remove(e.modifierClass + e.type), t.classList.remove(o.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (t.classList.remove(...(e.clickableClass || "").split(" ")), t.removeEventListener("click", a)) }))), o.pagination.bullets && o.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" ")))) } let { swiper: o, extendParams: d, on: c, emit: p } = e; const u = "swiper-pagination"; let m; d({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${u}-bullet`, bulletActiveClass: `${u}-bullet-active`, modifierClass: `${u}-`, currentClass: `${u}-current`, totalClass: `${u}-total`, hiddenClass: `${u}-hidden`, progressbarFillClass: `${u}-progressbar-fill`, progressbarOppositeClass: `${u}-progressbar-opposite`, clickableClass: `${u}-clickable`, lockClass: `${u}-lock`, horizontalClass: `${u}-horizontal`, verticalClass: `${u}-vertical`, paginationDisabledClass: `${u}-disabled` } }), o.pagination = { el: null, bullets: [] }; let h = 0; const f = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)); c("changeDirection", (() => { if (!o.pagination || !o.pagination.el) return; const e = o.params.pagination; let { el: t } = o.pagination; t = f(t), t.forEach((t => { t.classList.remove(e.horizontalClass, e.verticalClass), t.classList.add(o.isHorizontal() ? e.horizontalClass : e.verticalClass) })) })), c("init", (() => { !1 === o.params.pagination.enabled ? v() : (n(), r(), i()) })), c("activeIndexChange", (() => { void 0 === o.snapIndex && i() })), c("snapIndexChange", (() => { i() })), c("snapGridLengthChange", (() => { r(), i() })), c("destroy", (() => { l() })), c("enable disable", (() => { let { el: e } = o.pagination; e && (e = f(e), e.forEach((e => e.classList[o.enabled ? "remove" : "add"](o.params.pagination.lockClass)))) })), c("lock unlock", (() => { i() })), c("click", ((e, t) => { const s = t.target, a = f(o.pagination.el); if (o.params.pagination.el && o.params.pagination.hideOnClick && a && a.length > 0 && !s.classList.contains(o.params.pagination.bulletClass)) { if (o.navigation && (o.navigation.nextEl && s === o.navigation.nextEl || o.navigation.prevEl && s === o.navigation.prevEl)) return; const e = a[0].classList.contains(o.params.pagination.hiddenClass); p(!0 === e ? "paginationShow" : "paginationHide"), a.forEach((e => e.classList.toggle(o.params.pagination.hiddenClass))) } })); const g = () => { o.el.classList.remove(o.params.pagination.paginationDisabledClass); let { el: e } = o.pagination; e && (e = f(e), e.forEach((e => e.classList.remove(o.params.pagination.paginationDisabledClass)))), n(), r(), i() }, v = () => { o.el.classList.add(o.params.pagination.paginationDisabledClass); let { el: e } = o.pagination; e && (e = f(e), e.forEach((e => e.classList.add(o.params.pagination.paginationDisabledClass)))), l() }; Object.assign(o.pagination, { enable: g, disable: v, render: r, update: i, init: n, destroy: l }) } function Ye(e) { function t() { if (!v.params.scrollbar.el || !v.scrollbar.el) return; const { scrollbar: e, rtlTranslate: t } = v, { dragEl: s, el: a } = e, i = v.params.scrollbar, r = v.params.loop ? v.progressLoop : v.progress; let n = M, l = (C - M) * r; t ? (l = -l, l > 0 ? (n = M - l, l = 0) : -l + M > C && (n = C + l)) : l < 0 ? (n = M + l, l = 0) : l + M > C && (n = C - l), v.isHorizontal() ? (s.style.transform = `translate3d(${l}px, 0, 0)`, s.style.width = `${n}px`) : (s.style.transform = `translate3d(0px, ${l}px, 0)`, s.style.height = `${n}px`), i.hide && (clearTimeout(A), a.style.opacity = 1, A = setTimeout((() => { a.style.opacity = 0, a.style.transitionDuration = "400ms" }), 1e3)) } function s(e) { v.params.scrollbar.el && v.scrollbar.el && (v.scrollbar.dragEl.style.transitionDuration = `${e}ms`) } function a() { if (!v.params.scrollbar.el || !v.scrollbar.el) return; const { scrollbar: e } = v, { dragEl: t, el: s } = e; t.style.width = "", t.style.height = "", C = v.isHorizontal() ? s.offsetWidth : s.offsetHeight, P = v.size / (v.virtualSize + v.params.slidesOffsetBefore - (v.params.centeredSlides ? v.snapGrid[0] : 0)), M = "auto" === v.params.scrollbar.dragSize ? C * P : parseInt(v.params.scrollbar.dragSize, 10), v.isHorizontal() ? t.style.width = `${M}px` : t.style.height = `${M}px`, s.style.display = P >= 1 ? "none" : "", v.params.scrollbar.hide && (s.style.opacity = 0), v.params.watchOverflow && v.enabled && e.el.classList[v.isLocked ? "add" : "remove"](v.params.scrollbar.lockClass) } function i(e) { return v.isHorizontal() ? e.clientX : e.clientY } function n(e) { const { scrollbar: t, rtlTranslate: s } = v, { el: a } = t; let r; r = (i(e) - x(a)[v.isHorizontal() ? "left" : "top"] - (null !== T ? T : M / 2)) / (C - M), r = Math.max(Math.min(r, 1), 0), s && (r = 1 - r); const n = v.minTranslate() + (v.maxTranslate() - v.minTranslate()) * r; v.updateProgress(n), v.setTranslate(n), v.updateActiveIndex(), v.updateSlidesClasses() } function o(e) { const t = v.params.scrollbar, { scrollbar: s, wrapperEl: a } = v, { el: r, dragEl: l } = s; L = !0, T = e.target === l ? i(e) - e.target.getBoundingClientRect()[v.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), a.style.transitionDuration = "100ms", l.style.transitionDuration = "100ms", n(e), clearTimeout(I), r.style.transitionDuration = "0ms", t.hide && (r.style.opacity = 1), v.params.cssMode && (v.wrapperEl.style["scroll-snap-type"] = "none"), y("scrollbarDragStart", e) } function c(e) { const { scrollbar: t, wrapperEl: s } = v, { el: a, dragEl: i } = t; L && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, n(e), s.style.transitionDuration = "0ms", a.style.transitionDuration = "0ms", i.style.transitionDuration = "0ms", y("scrollbarDragMove", e)) } function p(e) { const t = v.params.scrollbar, { scrollbar: s, wrapperEl: a } = v, { el: i } = s; L && (L = !1, v.params.cssMode && (v.wrapperEl.style["scroll-snap-type"] = "", a.style.transitionDuration = ""), t.hide && (clearTimeout(I), I = d((() => { i.style.opacity = 0, i.style.transitionDuration = "400ms" }), 1e3)), y("scrollbarDragEnd", e), t.snapOnRelease && v.slideToClosest()) } function u(e) { const { scrollbar: t, params: s } = v, a = t.el; if (!a) return; const i = a, r = !!s.passiveListeners && { passive: !1, capture: !1 }, n = !!s.passiveListeners && { passive: !0, capture: !1 }; if (!i) return; const l = "on" === e ? "addEventListener" : "removeEventListener"; i[l]("pointerdown", o, r), S[l]("pointermove", c, r), S[l]("pointerup", p, n) } function m() { v.params.scrollbar.el && v.scrollbar.el && u("on") } function h() { v.params.scrollbar.el && v.scrollbar.el && u("off") } function f() { const { scrollbar: e, el: t } = v; v.params.scrollbar = Xe(v, v.originalParams.scrollbar, v.params.scrollbar, { el: "swiper-scrollbar" }); const s = v.params.scrollbar; if (!s.el) return; let a, i; if ("string" == typeof s.el && v.isElement && (a = v.el.querySelector(s.el)), a || "string" != typeof s.el) a || (a = s.el); else if (a = S.querySelectorAll(s.el), !a.length) return; v.params.uniqueNavElements && "string" == typeof s.el && a.length > 1 && 1 === t.querySelectorAll(s.el).length && (a = t.querySelector(s.el)), a.length > 0 && (a = a[0]), a.classList.add(v.isHorizontal() ? s.horizontalClass : s.verticalClass), a && (i = a.querySelector(Ne(v.params.scrollbar.dragClass)), i || (i = E("div", v.params.scrollbar.dragClass), a.append(i))), Object.assign(e, { el: a, dragEl: i }), s.draggable && m(), a && a.classList[v.enabled ? "remove" : "add"](...l(v.params.scrollbar.lockClass)) } function g() { const e = v.params.scrollbar, t = v.scrollbar.el; t && t.classList.remove(...l(v.isHorizontal() ? e.horizontalClass : e.verticalClass)), h() } let { swiper: v, extendParams: w, on: b, emit: y } = e; const S = r(); let T, M, C, P, L = !1, A = null, I = null; w({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), v.scrollbar = { el: null, dragEl: null }, b("init", (() => { !1 === v.params.scrollbar.enabled ? z() : (f(), a(), t()) })), b("update resize observerUpdate lock unlock", (() => { a() })), b("setTranslate", (() => { t() })), b("setTransition", ((e, t) => { s(t) })), b("enable disable", (() => { const { el: e } = v.scrollbar; e && e.classList[v.enabled ? "remove" : "add"](...l(v.params.scrollbar.lockClass)) })), b("destroy", (() => { g() })); const k = () => { v.el.classList.remove(...l(v.params.scrollbar.scrollbarDisabledClass)), v.scrollbar.el && v.scrollbar.el.classList.remove(...l(v.params.scrollbar.scrollbarDisabledClass)), f(), a(), t() }, z = () => { v.el.classList.add(...l(v.params.scrollbar.scrollbarDisabledClass)), v.scrollbar.el && v.scrollbar.el.classList.add(...l(v.params.scrollbar.scrollbarDisabledClass)), g() }; Object.assign(v.scrollbar, { enable: k, disable: z, updateSize: a, setTranslate: t, init: f, destroy: g }) } function Re(e) { let { swiper: t, extendParams: s, on: a } = e; s({ parallax: { enabled: !1 } }); const i = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", r = (e, s) => { const { rtl: a } = t, i = a ? -1 : 1, r = e.getAttribute("data-swiper-parallax") || "0"; let n = e.getAttribute("data-swiper-parallax-x"), l = e.getAttribute("data-swiper-parallax-y"); const o = e.getAttribute("data-swiper-parallax-scale"), d = e.getAttribute("data-swiper-parallax-opacity"), c = e.getAttribute("data-swiper-parallax-rotate"); if (n || l ? (n = n || "0", l = l || "0") : t.isHorizontal() ? (n = r, l = "0") : (l = r, n = "0"), n = n.indexOf("%") >= 0 ? parseInt(n, 10) * s * i + "%" : n * s * i + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s + "%" : l * s + "px", null != d) { const t = d - (d - 1) * (1 - Math.abs(s)); e.style.opacity = t } let p = `translate3d(${n}, ${l}, 0px)`; if (null != o) { p += ` scale(${o - (o - 1) * (1 - Math.abs(s))})` } if (c && null != c) { p += ` rotate(${c * s * -1}deg)` } e.style.transform = p }, n = () => { const { el: e, slides: s, progress: a, snapGrid: n, isElement: l } = t, o = b(e, i); t.isElement && o.push(...b(t.hostEl, i)), o.forEach((e => { r(e, a) })), s.forEach(((e, s) => { let l = e.progress; t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (l += Math.ceil(s / 2) - a * (n.length - 1)), l = Math.min(Math.max(l, -1), 1), e.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach((e => { r(e, l) })) })) }, l = function (e) { void 0 === e && (e = t.params.speed); const { el: s, hostEl: a } = t, r = [...s.querySelectorAll(i)]; t.isElement && r.push(...a.querySelectorAll(i)), r.forEach((t => { let s = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e; 0 === e && (s = 0), t.style.transitionDuration = `${s}ms` })) }; a("beforeInit", (() => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0) })), a("init", (() => { t.params.parallax.enabled && n() })), a("setTranslate", (() => { t.params.parallax.enabled && n() })), a("setTransition", ((e, s) => { t.params.parallax.enabled && l(s) })) } function Ve(e) { function t() { if ($.length < 2) return 1; const e = $[0].pageX, t = $[0].pageY, s = $[1].pageX, a = $[1].pageY; return Math.sqrt((s - e) ** 2 + (a - t) ** 2) } function s() { if ($.length < 2) return { x: null, y: null }; const e = O.imageEl.getBoundingClientRect(); return [($[0].pageX + ($[1].pageX - $[0].pageX) / 2 - e.x - L.scrollX) / k, ($[0].pageY + ($[1].pageY - $[0].pageY) / 2 - e.y - L.scrollY) / k] } function a() { return S.isElement ? "swiper-slide" : `.${S.params.slideClass}` } function i(e) { const t = a(); return !!e.target.matches(t) || S.slides.filter((t => t.contains(e.target))).length > 0 } function r(e) { const t = `.${S.params.zoom.containerClass}`; return !!e.target.matches(t) || [...S.hostEl.querySelectorAll(t)].filter((t => t.contains(e.target))).length > 0 } function l(e) { if ("mouse" === e.pointerType && $.splice(0, $.length), !i(e)) return; const a = S.params.zoom; if (A = !1, I = !1, $.push(e), !($.length < 2)) { if (A = !0, O.scaleStart = t(), !O.slideEl) { O.slideEl = e.target.closest(`.${S.params.slideClass}, swiper-slide`), O.slideEl || (O.slideEl = S.slides[S.activeIndex]); let t = O.slideEl.querySelector(`.${a.containerClass}`); if (t && (t = t.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), O.imageEl = t, O.imageWrapEl = t ? P(O.imageEl, `.${a.containerClass}`)[0] : void 0, !O.imageWrapEl) return void (O.imageEl = void 0); O.maxRatio = O.imageWrapEl.getAttribute("data-swiper-zoom") || a.maxRatio } if (O.imageEl) { const [e, t] = s(); O.originX = e, O.originY = t, O.imageEl.style.transitionDuration = "0ms" } z = !0 } } function o(e) { if (!i(e)) return; const s = S.params.zoom, a = S.zoom, r = $.findIndex((t => t.pointerId === e.pointerId)); r >= 0 && ($[r] = e), $.length < 2 || (I = !0, O.scaleMove = t(), O.imageEl && (a.scale = O.scaleMove / O.scaleStart * k, a.scale > O.maxRatio && (a.scale = O.maxRatio - 1 + (a.scale - O.maxRatio + 1) ** .5), a.scale < s.minRatio && (a.scale = s.minRatio + 1 - (s.minRatio - a.scale + 1) ** .5), O.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`)) } function d(e) { if (!i(e)) return; if ("mouse" === e.pointerType && "pointerout" === e.type) return; const t = S.params.zoom, s = S.zoom, a = $.findIndex((t => t.pointerId === e.pointerId)); a >= 0 && $.splice(a, 1), A && I && (A = !1, I = !1, O.imageEl && (s.scale = Math.max(Math.min(s.scale, O.maxRatio), t.minRatio), O.imageEl.style.transitionDuration = `${S.params.speed}ms`, O.imageEl.style.transform = `translate3d(0,0,0) scale(${s.scale})`, k = s.scale, z = !1, s.scale > 1 && O.slideEl ? O.slideEl.classList.add(`${t.zoomedSlideClass}`) : s.scale <= 1 && O.slideEl && O.slideEl.classList.remove(`${t.zoomedSlideClass}`), 1 === s.scale && (O.originX = 0, O.originY = 0, O.slideEl = void 0))) } function c(e) { const t = S.device; if (!O.imageEl) return; if (D.isTouched) return; t.android && e.cancelable && e.preventDefault(), D.isTouched = !0; const s = $.length > 0 ? $[0] : e; D.touchesStart.x = s.pageX, D.touchesStart.y = s.pageY } function p(e) { if (!i(e) || !r(e)) return; const t = S.zoom; if (!O.imageEl) return; if (!D.isTouched || !O.slideEl) return; D.isMoved || (D.width = O.imageEl.offsetWidth, D.height = O.imageEl.offsetHeight, D.startX = u(O.imageWrapEl, "x") || 0, D.startY = u(O.imageWrapEl, "y") || 0, O.slideWidth = O.slideEl.offsetWidth, O.slideHeight = O.slideEl.offsetHeight, O.imageWrapEl.style.transitionDuration = "0ms"); const s = D.width * t.scale, a = D.height * t.scale; if (s < O.slideWidth && a < O.slideHeight) return; D.minX = Math.min(O.slideWidth / 2 - s / 2, 0), D.maxX = -D.minX, D.minY = Math.min(O.slideHeight / 2 - a / 2, 0), D.maxY = -D.minY, D.touchesCurrent.x = $.length > 0 ? $[0].pageX : e.pageX, D.touchesCurrent.y = $.length > 0 ? $[0].pageY : e.pageY; if (Math.max(Math.abs(D.touchesCurrent.x - D.touchesStart.x), Math.abs(D.touchesCurrent.y - D.touchesStart.y)) > 5 && (S.allowClick = !1), !D.isMoved && !z) { if (S.isHorizontal() && (Math.floor(D.minX) === Math.floor(D.startX) && D.touchesCurrent.x < D.touchesStart.x || Math.floor(D.maxX) === Math.floor(D.startX) && D.touchesCurrent.x > D.touchesStart.x)) return void (D.isTouched = !1); if (!S.isHorizontal() && (Math.floor(D.minY) === Math.floor(D.startY) && D.touchesCurrent.y < D.touchesStart.y || Math.floor(D.maxY) === Math.floor(D.startY) && D.touchesCurrent.y > D.touchesStart.y)) return void (D.isTouched = !1) } e.cancelable && e.preventDefault(), e.stopPropagation(), D.isMoved = !0; const n = (t.scale - k) / (O.maxRatio - S.params.zoom.minRatio), { originX: l, originY: o } = O; D.currentX = D.touchesCurrent.x - D.touchesStart.x + D.startX + n * (D.width - 2 * l), D.currentY = D.touchesCurrent.y - D.touchesStart.y + D.startY + n * (D.height - 2 * o), D.currentX < D.minX && (D.currentX = D.minX + 1 - (D.minX - D.currentX + 1) ** .8), D.currentX > D.maxX && (D.currentX = D.maxX - 1 + (D.currentX - D.maxX + 1) ** .8), D.currentY < D.minY && (D.currentY = D.minY + 1 - (D.minY - D.currentY + 1) ** .8), D.currentY > D.maxY && (D.currentY = D.maxY - 1 + (D.currentY - D.maxY + 1) ** .8), G.prevPositionX || (G.prevPositionX = D.touchesCurrent.x), G.prevPositionY || (G.prevPositionY = D.touchesCurrent.y), G.prevTime || (G.prevTime = Date.now()), G.x = (D.touchesCurrent.x - G.prevPositionX) / (Date.now() - G.prevTime) / 2, G.y = (D.touchesCurrent.y - G.prevPositionY) / (Date.now() - G.prevTime) / 2, Math.abs(D.touchesCurrent.x - G.prevPositionX) < 2 && (G.x = 0), Math.abs(D.touchesCurrent.y - G.prevPositionY) < 2 && (G.y = 0), G.prevPositionX = D.touchesCurrent.x, G.prevPositionY = D.touchesCurrent.y, G.prevTime = Date.now(), O.imageWrapEl.style.transform = `translate3d(${D.currentX}px, ${D.currentY}px,0)` } function m() { const e = S.zoom; if (!O.imageEl) return; if (!D.isTouched || !D.isMoved) return D.isTouched = !1, void (D.isMoved = !1); D.isTouched = !1, D.isMoved = !1; let t = 300, s = 300; const a = G.x * t, i = D.currentX + a, r = G.y * s, n = D.currentY + r; 0 !== G.x && (t = Math.abs((i - D.currentX) / G.x)), 0 !== G.y && (s = Math.abs((n - D.currentY) / G.y)); const l = Math.max(t, s); D.currentX = i, D.currentY = n; const o = D.width * e.scale, d = D.height * e.scale; D.minX = Math.min(O.slideWidth / 2 - o / 2, 0), D.maxX = -D.minX, D.minY = Math.min(O.slideHeight / 2 - d / 2, 0), D.maxY = -D.minY, D.currentX = Math.max(Math.min(D.currentX, D.maxX), D.minX), D.currentY = Math.max(Math.min(D.currentY, D.maxY), D.minY), O.imageWrapEl.style.transitionDuration = `${l}ms`, O.imageWrapEl.style.transform = `translate3d(${D.currentX}px, ${D.currentY}px,0)` } function h() { const e = S.zoom; O.slideEl && S.activeIndex !== S.slides.indexOf(O.slideEl) && (O.imageEl && (O.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), O.imageWrapEl && (O.imageWrapEl.style.transform = "translate3d(0,0,0)"), O.slideEl.classList.remove(`${S.params.zoom.zoomedSlideClass}`), e.scale = 1, k = 1, O.slideEl = void 0, O.imageEl = void 0, O.imageWrapEl = void 0, O.originX = 0, O.originY = 0) } function f(e) { const t = S.zoom, s = S.params.zoom; if (!O.slideEl) { e && e.target && (O.slideEl = e.target.closest(`.${S.params.slideClass}, swiper-slide`)), O.slideEl || (S.params.virtual && S.params.virtual.enabled && S.virtual ? O.slideEl = b(S.slidesEl, `.${S.params.slideActiveClass}`)[0] : O.slideEl = S.slides[S.activeIndex]); let t = O.slideEl.querySelector(`.${s.containerClass}`); t && (t = t.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), O.imageEl = t, O.imageWrapEl = t ? P(O.imageEl, `.${s.containerClass}`)[0] : void 0 } if (!O.imageEl || !O.imageWrapEl) return; let a, i, r, n, l, o, d, c, p, u, m, h, f, g, v, w, y, E; S.params.cssMode && (S.wrapperEl.style.overflow = "hidden", S.wrapperEl.style.touchAction = "none"), O.slideEl.classList.add(`${s.zoomedSlideClass}`), void 0 === D.touchesStart.x && e ? (a = e.pageX, i = e.pageY) : (a = D.touchesStart.x, i = D.touchesStart.y); const T = "number" == typeof e ? e : null; 1 === k && T && (a = void 0, i = void 0), t.scale = T || O.imageWrapEl.getAttribute("data-swiper-zoom") || s.maxRatio, k = T || O.imageWrapEl.getAttribute("data-swiper-zoom") || s.maxRatio, !e || 1 === k && T ? (d = 0, c = 0) : (y = O.slideEl.offsetWidth, E = O.slideEl.offsetHeight, r = x(O.slideEl).left + L.scrollX, n = x(O.slideEl).top + L.scrollY, l = r + y / 2 - a, o = n + E / 2 - i, p = O.imageEl.offsetWidth, u = O.imageEl.offsetHeight, m = p * t.scale, h = u * t.scale, f = Math.min(y / 2 - m / 2, 0), g = Math.min(E / 2 - h / 2, 0), v = -f, w = -g, d = l * t.scale, c = o * t.scale, d < f && (d = f), d > v && (d = v), c < g && (c = g), c > w && (c = w)), T && 1 === t.scale && (O.originX = 0, O.originY = 0), O.imageWrapEl.style.transitionDuration = "300ms", O.imageWrapEl.style.transform = `translate3d(${d}px, ${c}px,0)`, O.imageEl.style.transitionDuration = "300ms", O.imageEl.style.transform = `translate3d(0,0,0) scale(${t.scale})` } function g() { const e = S.zoom, t = S.params.zoom; if (!O.slideEl) { S.params.virtual && S.params.virtual.enabled && S.virtual ? O.slideEl = b(S.slidesEl, `.${S.params.slideActiveClass}`)[0] : O.slideEl = S.slides[S.activeIndex]; let e = O.slideEl.querySelector(`.${t.containerClass}`); e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), O.imageEl = e, O.imageWrapEl = e ? P(O.imageEl, `.${t.containerClass}`)[0] : void 0 } O.imageEl && O.imageWrapEl && (S.params.cssMode && (S.wrapperEl.style.overflow = "", S.wrapperEl.style.touchAction = ""), e.scale = 1, k = 1, O.imageWrapEl.style.transitionDuration = "300ms", O.imageWrapEl.style.transform = "translate3d(0,0,0)", O.imageEl.style.transitionDuration = "300ms", O.imageEl.style.transform = "translate3d(0,0,0) scale(1)", O.slideEl.classList.remove(`${t.zoomedSlideClass}`), O.slideEl = void 0, O.originX = 0, O.originY = 0) } function v(e) { const t = S.zoom; t.scale && 1 !== t.scale ? g() : f(e) } function w() { return { passiveListener: !!S.params.passiveListeners && { passive: !0, capture: !1 }, activeListenerWithCapture: !S.params.passiveListeners || { passive: !1, capture: !0 } } } function y() { const e = S.zoom; if (e.enabled) return; e.enabled = !0; const { passiveListener: t, activeListenerWithCapture: s } = w(); S.wrapperEl.addEventListener("pointerdown", l, t), S.wrapperEl.addEventListener("pointermove", o, s), ["pointerup", "pointercancel", "pointerout"].forEach((e => { S.wrapperEl.addEventListener(e, d, t) })), S.wrapperEl.addEventListener("pointermove", p, s) } function E() { const e = S.zoom; if (!e.enabled) return; e.enabled = !1; const { passiveListener: t, activeListenerWithCapture: s } = w(); S.wrapperEl.removeEventListener("pointerdown", l, t), S.wrapperEl.removeEventListener("pointermove", o, s), ["pointerup", "pointercancel", "pointerout"].forEach((e => { S.wrapperEl.removeEventListener(e, d, t) })), S.wrapperEl.removeEventListener("pointermove", p, s) } let { swiper: S, extendParams: T, on: M, emit: C } = e; const L = n(); T({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), S.zoom = { enabled: !1 }; let A, I, k = 1, z = !1; const $ = [], O = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, D = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, G = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let X = 1; Object.defineProperty(S.zoom, "scale", { get: () => X, set(e) { if (X !== e) { const t = O.imageEl, s = O.slideEl; C("zoomChange", e, t, s) } X = e } }), M("init", (() => { S.params.zoom.enabled && y() })), M("destroy", (() => { E() })), M("touchStart", ((e, t) => { S.zoom.enabled && c(t) })), M("touchEnd", (() => { S.zoom.enabled && m() })), M("doubleTap", ((e, t) => { !S.animating && S.params.zoom.enabled && S.zoom.enabled && S.params.zoom.toggle && v(t) })), M("transitionEnd", (() => { S.zoom.enabled && S.params.zoom.enabled && h() })), M("slideChange", (() => { S.zoom.enabled && S.params.zoom.enabled && S.params.cssMode && h() })), Object.assign(S.zoom, { enable: y, disable: E, in: f, out: g, toggle: v }) } function qe(e) { function t(e, t) { const s = function () { let e, t, s; return (a, i) => { for (t = -1, e = a.length; e - t > 1;)s = e + t >> 1, a[s] <= i ? t = s : e = s; return e } }(); let a, i; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0 }, this } function s(e) { n.controller.spline = n.params.loop ? new t(n.slidesGrid, e.slidesGrid) : new t(n.snapGrid, e.snapGrid) } function a(e, t) { function a(e) { if (e.destroyed) return; const t = n.rtlTranslate ? -n.translate : n.translate; "slide" === n.params.controller.by && (s(e), l = -n.controller.spline.interpolate(-t)), l && "container" !== n.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (n.maxTranslate() - n.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), l = (t - n.minTranslate()) * r + e.minTranslate()), n.params.controller.inverse && (l = e.maxTranslate() - l), e.updateProgress(l), e.setTranslate(l, n), e.updateActiveIndex(), e.updateSlidesClasses() } const i = n.controller.control; let r, l; const o = n.constructor; if (Array.isArray(i)) for (let e = 0; e < i.length; e += 1)i[e] !== t && i[e] instanceof o && a(i[e]); else i instanceof o && t !== i && a(i) } function i(e, t) { function s(t) { t.destroyed || (t.setTransition(e, n), 0 !== e && (t.transitionStart(), t.params.autoHeight && d((() => { t.updateAutoHeight() })), L(t.wrapperEl, (() => { i && t.transitionEnd() })))) } const a = n.constructor, i = n.controller.control; let r; if (Array.isArray(i)) for (r = 0; r < i.length; r += 1)i[r] !== t && i[r] instanceof a && s(i[r]); else i instanceof a && t !== i && s(i) } function r() { n.controller.control && n.controller.spline && (n.controller.spline = void 0, delete n.controller.spline) } let { swiper: n, extendParams: l, on: o } = e; l({ controller: { control: void 0, inverse: !1, by: "slide" } }), n.controller = { control: void 0 }, o("beforeInit", (() => { if ("undefined" != typeof window && ("string" == typeof n.params.controller.control || n.params.controller.control instanceof HTMLElement)) { const e = document.querySelector(n.params.controller.control); if (e && e.swiper) n.controller.control = e.swiper; else if (e) { const t = s => { n.controller.control = s.detail[0], n.update(), e.removeEventListener("init", t) }; e.addEventListener("init", t) } } else n.controller.control = n.params.controller.control })), o("update", (() => { r() })), o("resize", (() => { r() })), o("observerUpdate", (() => { r() })), o("setTranslate", ((e, t, s) => { n.controller.control && !n.controller.control.destroyed && n.controller.setTranslate(t, s) })), o("setTransition", ((e, t, s) => { n.controller.control && !n.controller.control.destroyed && n.controller.setTransition(t, s) })), Object.assign(n.controller, { setTranslate: a, setTransition: i }) } function _e(e) {
      function t(e) { const t = S; 0 !== t.length && (t.innerHTML = "", t.innerHTML = e) } function s(e) { void 0 === e && (e = 16); const t = () => Math.round(16 * Math.random()).toString(16); return "x".repeat(e).replace(/x/g, t) } function a(e) { (e = T(e)).forEach((e => { e.setAttribute("tabIndex", "0") })) } function i(e) { (e = T(e)).forEach((e => { e.setAttribute("tabIndex", "-1") })) } function r(e, t) { (e = T(e)).forEach((e => { e.setAttribute("role", t) })) } function n(e, t) { (e = T(e)).forEach((e => { e.setAttribute("aria-roledescription", t) })) } function l(e, t) { (e = T(e)).forEach((e => { e.setAttribute("aria-controls", t) })) } function o(e, t) { (e = T(e)).forEach((e => { e.setAttribute("aria-label", t) })) } function d(e, t) { (e = T(e)).forEach((e => { e.setAttribute("id", t) })) } function c(e, t) { (e = T(e)).forEach((e => { e.setAttribute("aria-live", t) })) } function p(e) { (e = T(e)).forEach((e => { e.setAttribute("aria-disabled", !0) })) } function u(e) { (e = T(e)).forEach((e => { e.setAttribute("aria-disabled", !1) })) } function m(e) { if (13 !== e.keyCode && 32 !== e.keyCode) return; const s = b.params.a11y, a = e.target; b.pagination && b.pagination.el && (a === b.pagination.el || b.pagination.el.contains(e.target)) && !e.target.matches(Ne(b.params.pagination.bulletClass)) || (b.navigation && b.navigation.nextEl && a === b.navigation.nextEl && (b.isEnd && !b.params.loop || b.slideNext(), b.isEnd ? t(s.lastSlideMessage) : t(s.nextSlideMessage)), b.navigation && b.navigation.prevEl && a === b.navigation.prevEl && (b.isBeginning && !b.params.loop || b.slidePrev(), b.isBeginning ? t(s.firstSlideMessage) : t(s.prevSlideMessage)), b.pagination && a.matches(Ne(b.params.pagination.bulletClass)) && a.click()) } function h() { if (b.params.loop || b.params.rewind || !b.navigation) return; const { nextEl: e, prevEl: t } = b.navigation; t && (b.isBeginning ? (p(t), i(t)) : (u(t), a(t))), e && (b.isEnd ? (p(e), i(e)) : (u(e), a(e))) } function f() { return b.pagination && b.pagination.bullets && b.pagination.bullets.length } function g() { return f() && b.params.pagination.clickable } function v() { const e = b.params.a11y; f() && b.pagination.bullets.forEach((t => { b.params.pagination.clickable && (a(t), b.params.pagination.renderBullet || (r(t, "button"), o(t, e.paginationBulletMessage.replace(/\{\{index\}\}/, C(t) + 1)))), t.matches(Ne(b.params.pagination.bulletActiveClass)) ? t.setAttribute("aria-current", "true") : t.removeAttribute("aria-current") })) } function w() { S && S.remove(); let { nextEl: e, prevEl: t } = b.navigation ? b.navigation : {}; if (e = T(e), t = T(t), e && e.forEach((e => e.removeEventListener("keydown", m))), t && t.forEach((e => e.removeEventListener("keydown", m))), g()) { T(b.pagination.el).forEach((e => { e.removeEventListener("keydown", m) })) } b.el.removeEventListener("focus", A, !0), b.el.removeEventListener("pointerdown", P, !0), b.el.removeEventListener("pointerup", L, !0) } let { swiper: b, extendParams: y, on: x } = e; y({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), b.a11y = { clicked: !1 }; let S = null; const T = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)), M = (e, t, s) => {
        a(e), "BUTTON" !== e.tagName && (r(e, "button"), e.addEventListener("keydown", m)), o(e, s),
        l(e, t)
      }, P = () => { b.a11y.clicked = !0 }, L = () => { requestAnimationFrame((() => { requestAnimationFrame((() => { b.destroyed || (b.a11y.clicked = !1) })) })) }, A = e => { if (b.a11y.clicked) return; const t = e.target.closest(`.${b.params.slideClass}, swiper-slide`); if (!t || !b.slides.includes(t)) return; const s = b.slides.indexOf(t) === b.activeIndex, a = b.params.watchSlidesProgress && b.visibleSlides && b.visibleSlides.includes(t); s || a || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (b.isHorizontal() ? b.el.scrollLeft = 0 : b.el.scrollTop = 0, b.slideTo(b.slides.indexOf(t), 0)) }, I = () => { const e = b.params.a11y; e.itemRoleDescriptionMessage && n(b.slides, e.itemRoleDescriptionMessage), e.slideRole && r(b.slides, e.slideRole); const t = b.slides.length; e.slideLabelMessage && b.slides.forEach(((s, a) => { const i = b.params.loop ? parseInt(s.getAttribute("data-swiper-slide-index"), 10) : a; o(s, e.slideLabelMessage.replace(/\{\{index\}\}/, i + 1).replace(/\{\{slidesLength\}\}/, t)) })) }, k = () => { const e = b.params.a11y; b.el.append(S); const t = b.el; e.containerRoleDescriptionMessage && n(t, e.containerRoleDescriptionMessage), e.containerMessage && o(t, e.containerMessage); const a = b.wrapperEl, i = e.id || a.getAttribute("id") || `swiper-wrapper-${s(16)}`, r = b.params.autoplay && b.params.autoplay.enabled ? "off" : "polite"; d(a, i), c(a, r), I(); let { nextEl: l, prevEl: p } = b.navigation ? b.navigation : {}; if (l = T(l), p = T(p), l && l.forEach((t => M(t, i, e.nextSlideMessage))), p && p.forEach((t => M(t, i, e.prevSlideMessage))), g()) { T(b.pagination.el).forEach((e => { e.addEventListener("keydown", m) })) } b.el.addEventListener("focus", A, !0), b.el.addEventListener("pointerdown", P, !0), b.el.addEventListener("pointerup", L, !0) }; x("beforeInit", (() => { S = E("span", b.params.a11y.notificationClass), S.setAttribute("aria-live", "assertive"), S.setAttribute("aria-atomic", "true") })), x("afterInit", (() => { b.params.a11y.enabled && k() })), x("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => { b.params.a11y.enabled && I() })), x("fromEdge toEdge afterInit lock unlock", (() => { b.params.a11y.enabled && h() })), x("paginationUpdate", (() => { b.params.a11y.enabled && v() })), x("destroy", (() => { b.params.a11y.enabled && w() }))
    } function Fe(e) { let { swiper: t, extendParams: s, on: a } = e; s({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let i = !1, r = {}; const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), o = e => { const t = n(); let s; s = e ? new URL(e) : t.location; const a = s.pathname.slice(1).split("/").filter((e => "" !== e)), i = a.length; return { key: a[i - 2], value: a[i - 1] } }, d = (e, s) => { const a = n(); if (!i || !t.params.history.enabled) return; let r; r = t.params.url ? new URL(t.params.url) : a.location; const o = t.slides[s]; let d = l(o.getAttribute("data-history")); if (t.params.history.root.length > 0) { let s = t.params.history.root; "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e ? `${e}/` : ""}${d}` } else r.pathname.includes(e) || (d = `${e ? `${e}/` : ""}${d}`); t.params.history.keepQuery && (d += r.search); const c = a.history.state; c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({ value: d }, null, d) : a.history.pushState({ value: d }, null, d)) }, c = (e, s, a) => { if (s) for (let i = 0, r = t.slides.length; i < r; i += 1) { const r = t.slides[i]; if (l(r.getAttribute("data-history")) === s) { const s = t.getSlideIndex(r); t.slideTo(s, e, a) } } else t.slideTo(0, e, a) }, p = () => { r = o(t.params.url), c(t.params.speed, r.value, !1) }, u = () => { const e = n(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); i = !0, r = o(t.params.url), r.key || r.value ? (c(0, r.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", p)) : t.params.history.replaceState || e.addEventListener("popstate", p) } }, m = () => { const e = n(); t.params.history.replaceState || e.removeEventListener("popstate", p) }; a("init", (() => { t.params.history.enabled && u() })), a("destroy", (() => { t.params.history.enabled && m() })), a("transitionEnd _freeModeNoMomentumRelease", (() => { i && d(t.params.history.key, t.activeIndex) })), a("slideChange", (() => { i && t.params.cssMode && d(t.params.history.key, t.activeIndex) })) } function je(e) { let { swiper: t, extendParams: s, emit: a, on: i } = e, l = !1; const o = r(), d = n(); s({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(e, s) { if (t.virtual && t.params.virtual.enabled) { const e = t.slides.filter((e => e.getAttribute("data-hash") === s))[0]; if (!e) return 0; return parseInt(e.getAttribute("data-swiper-slide-index"), 10) } return t.getSlideIndex(b(t.slidesEl, `.${t.params.slideClass}[data-hash="${s}"], swiper-slide[data-hash="${s}"]`)[0]) } } }); const c = () => { a("hashChange"); const e = o.location.hash.replace("#", ""), s = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex]; if (e !== (s ? s.getAttribute("data-hash") : "")) { const s = t.params.hashNavigation.getSlideIndex(t, e); if (void 0 === s || Number.isNaN(s)) return; t.slideTo(s) } }, p = () => { if (!l || !t.params.hashNavigation.enabled) return; const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex], s = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : ""; t.params.hashNavigation.replaceState && d.history && d.history.replaceState ? (d.history.replaceState(null, null, `#${s}` || ""), a("hashSet")) : (o.location.hash = s || "", a("hashSet")) }, u = () => { if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return; l = !0; const e = o.location.hash.replace("#", ""); if (e) { const s = 0, a = t.params.hashNavigation.getSlideIndex(t, e); t.slideTo(a || 0, s, t.params.runCallbacksOnInit, !0) } t.params.hashNavigation.watchState && d.addEventListener("hashchange", c) }, m = () => { t.params.hashNavigation.watchState && d.removeEventListener("hashchange", c) }; i("init", (() => { t.params.hashNavigation.enabled && u() })), i("destroy", (() => { t.params.hashNavigation.enabled && m() })), i("transitionEnd _freeModeNoMomentumRelease", (() => { l && p() })), i("slideChange", (() => { l && t.params.cssMode && p() })) } function We(e) { function t(e) { i && !i.destroyed && i.wrapperEl && e.target === i.wrapperEl && (i.wrapperEl.removeEventListener("transitionend", t), v || P()) } let s, a, { swiper: i, extendParams: n, on: l, emit: o, params: d } = e; i.autoplay = { running: !1, paused: !1, timeLeft: 0 }, n({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let c, p, u, m, h, f, g, v, w = d && d.autoplay ? d.autoplay.delay : 3e3, b = d && d.autoplay ? d.autoplay.delay : 3e3, y = (new Date).getTime(); const E = () => { if (i.destroyed || !i.autoplay.running) return; i.autoplay.paused ? p = !0 : p && (b = c, p = !1); const e = i.autoplay.paused ? c : y + b - (new Date).getTime(); i.autoplay.timeLeft = e, o("autoplayTimeLeft", e, e / w), a = requestAnimationFrame((() => { E() })) }, x = () => { let e; if (e = i.virtual && i.params.virtual.enabled ? i.slides.filter((e => e.classList.contains("swiper-slide-active")))[0] : i.slides[i.activeIndex], !e) return; return parseInt(e.getAttribute("data-swiper-autoplay"), 10) }, S = e => { if (i.destroyed || !i.autoplay.running) return; cancelAnimationFrame(a), E(); let t = void 0 === e ? i.params.autoplay.delay : e; w = i.params.autoplay.delay, b = i.params.autoplay.delay; const r = x(); !Number.isNaN(r) && r > 0 && void 0 === e && (t = r, w = r, b = r), c = t; const n = i.params.speed, l = () => { i && !i.destroyed && (i.params.autoplay.reverseDirection ? !i.isBeginning || i.params.loop || i.params.rewind ? (i.slidePrev(n, !0, !0), o("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(i.slides.length - 1, n, !0, !0), o("autoplay")) : !i.isEnd || i.params.loop || i.params.rewind ? (i.slideNext(n, !0, !0), o("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(0, n, !0, !0), o("autoplay")), i.params.cssMode && (y = (new Date).getTime(), requestAnimationFrame((() => { S() })))) }; return t > 0 ? (clearTimeout(s), s = setTimeout((() => { l() }), t)) : requestAnimationFrame((() => { l() })), t }, T = () => { y = (new Date).getTime(), i.autoplay.running = !0, S(), o("autoplayStart") }, M = () => { i.autoplay.running = !1, clearTimeout(s), cancelAnimationFrame(a), o("autoplayStop") }, C = (e, a) => { if (i.destroyed || !i.autoplay.running) return; clearTimeout(s), e || (g = !0); const r = () => { o("autoplayPause"), i.params.autoplay.waitForTransition ? i.wrapperEl.addEventListener("transitionend", t) : P() }; if (i.autoplay.paused = !0, a) return f && (c = i.params.autoplay.delay), f = !1, void r(); const n = c || i.params.autoplay.delay; c = n - ((new Date).getTime() - y), i.isEnd && c < 0 && !i.params.loop || (c < 0 && (c = 0), r()) }, P = () => { i.isEnd && c < 0 && !i.params.loop || i.destroyed || !i.autoplay.running || (y = (new Date).getTime(), g ? (g = !1, S(c)) : S(), i.autoplay.paused = !1, o("autoplayResume")) }, L = () => { if (i.destroyed || !i.autoplay.running) return; const e = r(); "hidden" === e.visibilityState && (g = !0, C(!0)), "visible" === e.visibilityState && P() }, A = e => { "mouse" === e.pointerType && (g = !0, v = !0, i.animating || i.autoplay.paused || C(!0)) }, I = e => { "mouse" === e.pointerType && (v = !1, i.autoplay.paused && P()) }, k = () => { i.params.autoplay.pauseOnMouseEnter && (i.el.addEventListener("pointerenter", A), i.el.addEventListener("pointerleave", I)) }, z = () => { i.el.removeEventListener("pointerenter", A), i.el.removeEventListener("pointerleave", I) }, $ = () => { r().addEventListener("visibilitychange", L) }, O = () => { r().removeEventListener("visibilitychange", L) }; l("init", (() => { i.params.autoplay.enabled && (k(), $(), T()) })), l("destroy", (() => { z(), O(), i.autoplay.running && M() })), l("_freeModeStaticRelease", (() => { (m || g) && P() })), l("_freeModeNoMomentumRelease", (() => { i.params.autoplay.disableOnInteraction ? M() : C(!0, !0) })), l("beforeTransitionStart", ((e, t, s) => { !i.destroyed && i.autoplay.running && (s || !i.params.autoplay.disableOnInteraction ? C(!0, !0) : M()) })), l("sliderFirstMove", (() => { !i.destroyed && i.autoplay.running && (i.params.autoplay.disableOnInteraction ? M() : (u = !0, m = !1, g = !1, h = setTimeout((() => { g = !0, m = !0, C(!0) }), 200))) })), l("touchEnd", (() => { if (!i.destroyed && i.autoplay.running && u) { if (clearTimeout(h), clearTimeout(s), i.params.autoplay.disableOnInteraction) return m = !1, void (u = !1); m && i.params.cssMode && P(), m = !1, u = !1 } })), l("slideChange", (() => { !i.destroyed && i.autoplay.running && (f = !0) })), Object.assign(i.autoplay, { start: T, stop: M, pause: C, resume: P }) } function Ue(e) { function t() { const e = i.thumbs.swiper; if (!e || e.destroyed) return; const t = e.clickedIndex, s = e.clickedSlide; if (s && s.classList.contains(i.params.thumbs.slideThumbActiveClass)) return; if (null == t) return; let a; a = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : t, i.params.loop ? i.slideToLoop(a) : i.slideTo(a) } function s() { const { thumbs: e } = i.params; if (o) return !1; o = !0; const s = i.constructor; if (e.swiper instanceof s) i.thumbs.swiper = e.swiper, Object.assign(i.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(i.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), i.thumbs.swiper.update(); else if (m(e.swiper)) { const t = Object.assign({}, e.swiper); Object.assign(t, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), i.thumbs.swiper = new s(t), d = !0 } return i.thumbs.swiper.el.classList.add(i.params.thumbs.thumbsContainerClass), i.thumbs.swiper.on("tap", t), !0 } function a(e) { const t = i.thumbs.swiper; if (!t || t.destroyed) return; const s = "auto" === t.params.slidesPerView ? t.slidesPerViewDynamic() : t.params.slidesPerView; let a = 1; const r = i.params.thumbs.slideThumbActiveClass; if (i.params.slidesPerView > 1 && !i.params.centeredSlides && (a = i.params.slidesPerView), i.params.thumbs.multipleActiveThumbs || (a = 1), a = Math.floor(a), t.slides.forEach((e => e.classList.remove(r))), t.params.loop || t.params.virtual && t.params.virtual.enabled) for (let e = 0; e < a; e += 1)b(t.slidesEl, `[data-swiper-slide-index="${i.realIndex + e}"]`).forEach((e => { e.classList.add(r) })); else for (let e = 0; e < a; e += 1)t.slides[i.realIndex + e] && t.slides[i.realIndex + e].classList.add(r); const n = i.params.thumbs.autoScrollOffset, l = n && !t.params.loop; if (i.realIndex !== t.realIndex || l) { const a = t.activeIndex; let r, o; if (t.params.loop) { const e = t.slides.filter((e => e.getAttribute("data-swiper-slide-index") === `${i.realIndex}`))[0]; r = t.slides.indexOf(e), o = i.activeIndex > i.previousIndex ? "next" : "prev" } else r = i.realIndex, o = r > i.previousIndex ? "next" : "prev"; l && (r += "next" === o ? n : -1 * n), t.visibleSlidesIndexes && t.visibleSlidesIndexes.indexOf(r) < 0 && (t.params.centeredSlides ? r = r > a ? r - Math.floor(s / 2) + 1 : r + Math.floor(s / 2) - 1 : r > a && t.params.slidesPerGroup, t.slideTo(r, e ? 0 : void 0)) } } let { swiper: i, extendParams: n, on: l } = e; n({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let o = !1, d = !1; i.thumbs = { swiper: null }, l("beforeInit", (() => { const { thumbs: e } = i.params; if (e && e.swiper) if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) { const t = r(), n = () => { const r = "string" == typeof e.swiper ? t.querySelector(e.swiper) : e.swiper; if (r && r.swiper) e.swiper = r.swiper, s(), a(!0); else if (r) { const t = n => { e.swiper = n.detail[0], r.removeEventListener("init", t), s(), a(!0), e.swiper.update(), i.update() }; r.addEventListener("init", t) } return r }, l = () => { if (i.destroyed) return; n() || requestAnimationFrame(l) }; requestAnimationFrame(l) } else s(), a(!0) })), l("slideChange update resize observerUpdate", (() => { a() })), l("setTransition", ((e, t) => { const s = i.thumbs.swiper; s && !s.destroyed && s.setTransition(t) })), l("beforeDestroy", (() => { const e = i.thumbs.swiper; e && !e.destroyed && d && e.destroy() })), Object.assign(i.thumbs, { init: s, update: a }) } function Ke(e) { function t() { if (i.params.cssMode) return; const e = i.getTranslate(); i.setTranslate(e), i.setTransition(0), i.touchEventsData.velocities.length = 0, i.freeMode.onTouchEnd({ currentPos: i.rtl ? i.translate : -i.translate }) } function s() { if (i.params.cssMode) return; const { touchEventsData: e, touches: t } = i; 0 === e.velocities.length && e.velocities.push({ position: t[i.isHorizontal() ? "startX" : "startY"], time: e.touchStartTime }), e.velocities.push({ position: t[i.isHorizontal() ? "currentX" : "currentY"], time: c() }) } function a(e) { let { currentPos: t } = e; if (i.params.cssMode) return; const { params: s, wrapperEl: a, rtlTranslate: r, snapGrid: o, touchEventsData: d } = i, p = c() - d.touchStartTime; if (t < -i.minTranslate()) i.slideTo(i.activeIndex); else if (t > -i.maxTranslate()) i.slides.length < o.length ? i.slideTo(o.length - 1) : i.slideTo(i.slides.length - 1); else { if (s.freeMode.momentum) { if (d.velocities.length > 1) { const e = d.velocities.pop(), t = d.velocities.pop(), a = e.position - t.position, r = e.time - t.time; i.velocity = a / r, i.velocity /= 2, Math.abs(i.velocity) < s.freeMode.minimumVelocity && (i.velocity = 0), (r > 150 || c() - e.time > 300) && (i.velocity = 0) } else i.velocity = 0; i.velocity *= s.freeMode.momentumVelocityRatio, d.velocities.length = 0; let e = 1e3 * s.freeMode.momentumRatio; const t = i.velocity * e; let p = i.translate + t; r && (p = -p); let u, m = !1; const h = 20 * Math.abs(i.velocity) * s.freeMode.momentumBounceRatio; let f; if (p < i.maxTranslate()) s.freeMode.momentumBounce ? (p + i.maxTranslate() < -h && (p = i.maxTranslate() - h), u = i.maxTranslate(), m = !0, d.allowMomentumBounce = !0) : p = i.maxTranslate(), s.loop && s.centeredSlides && (f = !0); else if (p > i.minTranslate()) s.freeMode.momentumBounce ? (p - i.minTranslate() > h && (p = i.minTranslate() + h), u = i.minTranslate(), m = !0, d.allowMomentumBounce = !0) : p = i.minTranslate(), s.loop && s.centeredSlides && (f = !0); else if (s.freeMode.sticky) { let e; for (let t = 0; t < o.length; t += 1)if (o[t] > -p) { e = t; break } p = Math.abs(o[e] - p) < Math.abs(o[e - 1] - p) || "next" === i.swipeDirection ? o[e] : o[e - 1], p = -p } if (f && l("transitionEnd", (() => { i.loopFix() })), 0 !== i.velocity) { if (e = r ? Math.abs((-p - i.translate) / i.velocity) : Math.abs((p - i.translate) / i.velocity), s.freeMode.sticky) { const t = Math.abs((r ? -p : p) - i.translate), a = i.slidesSizesGrid[i.activeIndex]; e = t < a ? s.speed : t < 2 * a ? 1.5 * s.speed : 2.5 * s.speed } } else if (s.freeMode.sticky) return void i.slideToClosest(); s.freeMode.momentumBounce && m ? (i.updateProgress(u), i.setTransition(e), i.setTranslate(p), i.transitionStart(!0, i.swipeDirection), i.animating = !0, L(a, (() => { i && !i.destroyed && d.allowMomentumBounce && (n("momentumBounce"), i.setTransition(s.speed), setTimeout((() => { i.setTranslate(u), L(a, (() => { i && !i.destroyed && i.transitionEnd() })) }), 0)) }))) : i.velocity ? (n("_freeModeNoMomentumRelease"), i.updateProgress(p), i.setTransition(e), i.setTranslate(p), i.transitionStart(!0, i.swipeDirection), i.animating || (i.animating = !0, L(a, (() => { i && !i.destroyed && i.transitionEnd() })))) : i.updateProgress(p), i.updateActiveIndex(), i.updateSlidesClasses() } else { if (s.freeMode.sticky) return void i.slideToClosest(); s.freeMode && n("_freeModeNoMomentumRelease") } (!s.freeMode.momentum || p >= s.longSwipesMs) && (n("_freeModeStaticRelease"), i.updateProgress(), i.updateActiveIndex(), i.updateSlidesClasses()) } } let { swiper: i, extendParams: r, emit: n, once: l } = e; r({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(i, { freeMode: { onTouchStart: t, onTouchMove: s, onTouchEnd: a } }) } function Ze(e) { let t, s, a, i, { swiper: r, extendParams: n, on: l } = e; n({ grid: { rows: 1, fill: "column" } }); const o = () => { let e = r.params.spaceBetween; return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * r.size : "string" == typeof e && (e = parseFloat(e)), e }, d = e => { const { slidesPerView: i } = r.params, { rows: n, fill: l } = r.params.grid, o = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : e.length; a = Math.floor(o / n), t = Math.floor(o / n) === o / n ? o : Math.ceil(o / n) * n, "auto" !== i && "row" === l && (t = Math.max(t, i * n)), s = t / n }, c = () => { r.slides && r.slides.forEach((e => { e.swiperSlideGridSet && (e.style.height = "", e.style[r.getDirectionLabel("margin-top")] = "") })) }, p = (e, i, n) => { const { slidesPerGroup: l } = r.params, d = o(), { rows: c, fill: p } = r.params.grid, u = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : n.length; let m, h, f; if ("row" === p && l > 1) { const s = Math.floor(e / (l * c)), a = e - c * l * s, r = 0 === s ? l : Math.min(Math.ceil((u - s * c * l) / c), l); f = Math.floor(a / r), h = a - f * r + s * l, m = h + f * t / c, i.style.order = m } else "column" === p ? (h = Math.floor(e / c), f = e - h * c, (h > a || h === a && f === c - 1) && (f += 1, f >= c && (f = 0, h += 1))) : (f = Math.floor(e / s), h = e - f * s); i.row = f, i.column = h, i.style.height = `calc((100% - ${(c - 1) * d}px) / ${c})`, i.style[r.getDirectionLabel("margin-top")] = 0 !== f ? d && `${d}px` : "", i.swiperSlideGridSet = !0 }, u = (e, s) => { const { centeredSlides: a, roundLengths: i } = r.params, n = o(), { rows: l } = r.params.grid; if (r.virtualSize = (e + n) * t, r.virtualSize = Math.ceil(r.virtualSize / l) - n, r.params.cssMode || (r.wrapperEl.style[r.getDirectionLabel("width")] = `${r.virtualSize + n}px`), a) { const e = []; for (let t = 0; t < s.length; t += 1) { let a = s[t]; i && (a = Math.floor(a)), s[t] < r.virtualSize + s[0] && e.push(a) } s.splice(0, s.length), s.push(...e) } }, m = () => { const { params: e, el: t } = r, s = e.grid && e.grid.rows > 1; i && !s ? (t.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`), a = 1, r.emitContainerClasses()) : !i && s && (t.classList.add(`${e.containerModifierClass}grid`), "column" === e.grid.fill && t.classList.add(`${e.containerModifierClass}grid-column`), r.emitContainerClasses()), i = s }; l("init", (() => { i = r.params.grid && r.params.grid.rows > 1 })), l("update", m), r.grid = { initSlides: d, unsetSlides: c, updateSlide: p, updateWrapperSize: u } } function Qe(e) { const t = this, { params: s, slidesEl: a } = t; s.loop && t.loopDestroy(); const i = e => { if ("string" == typeof e) { const t = document.createElement("div"); t.innerHTML = e, a.append(t.children[0]), t.innerHTML = "" } else a.append(e) }; if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && i(e[t]); else i(e); t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update() } function Je(e) { const t = this, { params: s, activeIndex: a, slidesEl: i } = t; s.loop && t.loopDestroy(); let r = a + 1; const n = e => { if ("string" == typeof e) { const t = document.createElement("div"); t.innerHTML = e, i.prepend(t.children[0]), t.innerHTML = "" } else i.prepend(e) }; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && n(e[t]); r = a + e.length } else n(e); t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), t.slideTo(r, 0, !1) } function et(e, t) { const s = this, { params: a, activeIndex: i, slidesEl: r } = s; let n = i; a.loop && (n -= s.loopedSlides, s.loopDestroy(), s.recalcSlides()); const l = s.slides.length; if (e <= 0) return void s.prependSlide(t); if (e >= l) return void s.appendSlide(t); let o = n > e ? n + 1 : n; const d = []; for (let t = l - 1; t >= e; t -= 1) { const e = s.slides[t]; e.remove(), d.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && r.append(t[e]); o = n > e ? n + t.length : n } else r.append(t); for (let e = 0; e < d.length; e += 1)r.append(d[e]); s.recalcSlides(), a.loop && s.loopCreate(), a.observer && !s.isElement || s.update(), a.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1) } function tt(e) { const t = this, { params: s, activeIndex: a } = t; let i = a; s.loop && (i -= t.loopedSlides, t.loopDestroy()); let r, n = i; if ("object" == typeof e && "length" in e) { for (let s = 0; s < e.length; s += 1)r = e[s], t.slides[r] && t.slides[r].remove(), r < n && (n -= 1); n = Math.max(n, 0) } else r = e, t.slides[r] && t.slides[r].remove(), r < n && (n -= 1), n = Math.max(n, 0); t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), s.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1) } function st() { const e = this, t = []; for (let s = 0; s < e.slides.length; s += 1)t.push(s); e.removeSlide(t) } function at(e) { let { swiper: t } = e; Object.assign(t, { appendSlide: Qe.bind(t), prependSlide: Je.bind(t), addSlide: et.bind(t), removeSlide: tt.bind(t), removeAllSlides: st.bind(t) }) } function it(e) { const { effect: t, swiper: s, on: a, setTranslate: i, setTransition: r, overwriteParams: n, perspective: l, recreateShadows: o, getEffectParams: d } = e; let c; a("beforeInit", (() => { if (s.params.effect !== t) return; s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`); const e = n ? n() : {}; Object.assign(s.params, e), Object.assign(s.originalParams, e) })), a("setTranslate", (() => { s.params.effect === t && i() })), a("setTransition", ((e, a) => { s.params.effect === t && r(a) })), a("transitionEnd", (() => { if (s.params.effect === t && o) { if (!d || !d().slideShadows) return; s.slides.forEach((e => { e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((e => e.remove())) })), o() } })), a("virtualUpdate", (() => { s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => { c && s.slides && s.slides.length && (i(), c = !1) }))) })) } function rt(e, t) { const s = w(t); return s !== t && (s.style.backfaceVisibility = "hidden", s.style["-webkit-backface-visibility"] = "hidden"), s } function nt(e) { let { swiper: t, duration: s, transformElements: a, allSlides: i } = e; const { activeIndex: r } = t, n = e => { if (!e.parentElement) { return t.slides.filter((t => t.shadowRoot && t.shadowRoot === e.parentNode))[0] } return e.parentElement }; if (t.params.virtualTranslate && 0 !== s) { let e, s = !1; e = i ? a : a.filter((e => { const s = e.classList.contains("swiper-slide-transform") ? n(e) : e; return t.getSlideIndex(s) === r })), e.forEach((e => { L(e, (() => { if (s) return; if (!t || t.destroyed) return; s = !0, t.animating = !1; const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(e) })) })) } } function lt(e) { let { swiper: t, extendParams: s, on: a } = e; s({ fadeEffect: { crossFade: !1 } }); const i = () => { const { slides: e } = t, s = t.params.fadeEffect; for (let a = 0; a < e.length; a += 1) { const e = t.slides[a]; let i = -e.swiperSlideOffset; t.params.virtualTranslate || (i -= t.translate); let r = 0; t.isHorizontal() || (r = i, i = 0); const n = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0), l = rt(s, e); l.style.opacity = n, l.style.transform = `translate3d(${i}px, ${r}px, 0px)` } }, r = e => { const s = t.slides.map((e => w(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms` })), nt({ swiper: t, duration: e, transformElements: s, allSlides: !0 }) }; it({ effect: "fade", swiper: t, on: a, setTranslate: i, setTransition: r, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) } function ot(e) { let { swiper: t, extendParams: s, on: a } = e; s({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const i = (e, t, s) => { let a = s ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"), i = s ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom"); a || (a = E("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (s ? "left" : "top")).split(" ")), e.append(a)), i || (i = E("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (s ? "right" : "bottom")).split(" ")), e.append(i)), a && (a.style.opacity = Math.max(-t, 0)), i && (i.style.opacity = Math.max(t, 0)) }, r = () => { const e = t.isHorizontal(); t.slides.forEach((t => { const s = Math.max(Math.min(t.progress, 1), -1); i(t, s, e) })) }, n = () => { const { el: e, wrapperEl: s, slides: a, width: r, height: n, rtlTranslate: l, size: o, browser: d } = t, c = t.params.cubeEffect, p = t.isHorizontal(), u = t.virtual && t.params.virtual.enabled; let m, h = 0; c.shadow && (p ? (m = t.wrapperEl.querySelector(".swiper-cube-shadow"), m || (m = E("div", "swiper-cube-shadow"), t.wrapperEl.append(m)), m.style.height = `${r}px`) : (m = e.querySelector(".swiper-cube-shadow"), m || (m = E("div", "swiper-cube-shadow"), e.append(m)))); for (let e = 0; e < a.length; e += 1) { const s = a[e]; let r = e; u && (r = parseInt(s.getAttribute("data-swiper-slide-index"), 10)); let n = 90 * r, d = Math.floor(n / 360); l && (n = -n, d = Math.floor(-n / 360)); const m = Math.max(Math.min(s.progress, 1), -1); let f = 0, g = 0, v = 0; r % 4 == 0 ? (f = 4 * -d * o, v = 0) : (r - 1) % 4 == 0 ? (f = 0, v = 4 * -d * o) : (r - 2) % 4 == 0 ? (f = o + 4 * d * o, v = o) : (r - 3) % 4 == 0 && (f = -o, v = 3 * o + 4 * o * d), l && (f = -f), p || (g = f, f = 0); const w = `rotateX(${p ? 0 : -n}deg) rotateY(${p ? n : 0}deg) translate3d(${f}px, ${g}px, ${v}px)`; m <= 1 && m > -1 && (h = 90 * r + 90 * m, l && (h = 90 * -r - 90 * m), t.browser && t.browser.isSafari && Math.abs(h) / 90 % 2 == 1 && (h += .001)), s.style.transform = w, c.slideShadows && i(s, m, p) } if (s.style.transformOrigin = `50% 50% -${o / 2}px`, s.style["-webkit-transform-origin"] = `50% 50% -${o / 2}px`, c.shadow) if (p) m.style.transform = `translate3d(0px, ${r / 2 + c.shadowOffset}px, ${-r / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${c.shadowScale})`; else { const e = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), s = c.shadowScale, a = c.shadowScale / t, i = c.shadowOffset; m.style.transform = `scale3d(${s}, 1, ${a}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / a}px) rotateX(-89.99deg)` } const f = (d.isSafari || d.isWebView) && d.needPerspectiveFix ? -o / 2 : 0; s.style.transform = `translate3d(0px,0,${f}px) rotateX(${t.isHorizontal() ? 0 : h}deg) rotateY(${t.isHorizontal() ? -h : 0}deg)`, s.style.setProperty("--swiper-cube-translate-z", `${f}px`) }, l = e => { const { el: s, slides: a } = t; if (a.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), t.params.cubeEffect.shadow && !t.isHorizontal()) { const t = s.querySelector(".swiper-cube-shadow"); t && (t.style.transitionDuration = `${e}ms`) } }; it({ effect: "cube", swiper: t, on: a, setTranslate: n, setTransition: l, recreateShadows: r, getEffectParams: () => t.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) } function dt(e, t, s) { const a = `swiper-slide-shadow${s ? `-${s}` : ""}${e ? ` swiper-slide-shadow-${e}` : ""}`, i = w(t); let r = i.querySelector(`.${a.split(" ").join(".")}`); return r || (r = E("div", a.split(" ")), i.append(r)), r } function ct(e) { let { swiper: t, extendParams: s, on: a } = e; s({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const i = (e, s) => { let a = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"), i = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom"); a || (a = dt("flip", e, t.isHorizontal() ? "left" : "top")), i || (i = dt("flip", e, t.isHorizontal() ? "right" : "bottom")), a && (a.style.opacity = Math.max(-s, 0)), i && (i.style.opacity = Math.max(s, 0)) }, r = () => { t.params.flipEffect, t.slides.forEach((e => { let s = e.progress; t.params.flipEffect.limitRotation && (s = Math.max(Math.min(e.progress, 1), -1)), i(e, s) })) }, n = () => { const { slides: e, rtlTranslate: s } = t, a = t.params.flipEffect; for (let r = 0; r < e.length; r += 1) { const n = e[r]; let l = n.progress; t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n.progress, 1), -1)); const o = n.swiperSlideOffset; let d = -180 * l, c = 0, p = t.params.cssMode ? -o - t.translate : -o, u = 0; t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), t.browser && t.browser.isSafari && (Math.abs(d) / 90 % 2 == 1 && (d += .001), Math.abs(c) / 90 % 2 == 1 && (c += .001)), n.style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l); const m = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`; rt(a, n).style.transform = m } }, l = e => { const s = t.slides.map((e => w(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), nt({ swiper: t, duration: e, transformElements: s }) }; it({ effect: "flip", swiper: t, on: a, setTranslate: n, setTransition: l, recreateShadows: r, getEffectParams: () => t.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) } function pt(e) { let { swiper: t, extendParams: s, on: a } = e; s({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }); const i = () => { const { width: e, height: s, slides: a, slidesSizesGrid: i } = t, r = t.params.coverflowEffect, n = t.isHorizontal(), l = t.translate, o = n ? e / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate, c = r.depth; for (let e = 0, s = a.length; e < s; e += 1) { const s = a[e], l = i[e], p = (o - s.swiperSlideOffset - l / 2) / l, u = "function" == typeof r.modifier ? r.modifier(p) : p * r.modifier; let m = n ? d * u : 0, h = n ? 0 : d * u, f = -c * Math.abs(u), g = r.stretch; "string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(r.stretch) / 100 * l); let v = n ? 0 : g * u, w = n ? g * u : 0, b = 1 - (1 - r.scale) * Math.abs(u); Math.abs(w) < .001 && (w = 0), Math.abs(v) < .001 && (v = 0), Math.abs(f) < .001 && (f = 0), Math.abs(m) < .001 && (m = 0), Math.abs(h) < .001 && (h = 0), Math.abs(b) < .001 && (b = 0), t.browser && t.browser.isSafari && (Math.abs(m) / 90 % 2 == 1 && (m += .001), Math.abs(h) / 90 % 2 == 1 && (h += .001)); const y = `translate3d(${w}px,${v}px,${f}px)  rotateX(${h}deg) rotateY(${m}deg) scale(${b})`; if (rt(r, s).style.transform = y, s.style.zIndex = 1 - Math.abs(Math.round(u)), r.slideShadows) { let e = n ? s.querySelector(".swiper-slide-shadow-left") : s.querySelector(".swiper-slide-shadow-top"), t = n ? s.querySelector(".swiper-slide-shadow-right") : s.querySelector(".swiper-slide-shadow-bottom"); e || (e = dt("coverflow", s, n ? "left" : "top")), t || (t = dt("coverflow", s, n ? "right" : "bottom")), e && (e.style.opacity = u > 0 ? u : 0), t && (t.style.opacity = -u > 0 ? -u : 0) } } }, r = e => { t.slides.map((e => w(e))).forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => { t.style.transitionDuration = `${e}ms` })) })) }; it({ effect: "coverflow", swiper: t, on: a, setTranslate: i, setTransition: r, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) } function ut(e) { let { swiper: t, extendParams: s, on: a } = e; s({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const i = e => "string" == typeof e ? e : `${e}px`, r = () => { const { slides: e, wrapperEl: s, slidesSizesGrid: a } = t, r = t.params.creativeEffect, { progressMultiplier: n } = r, l = t.params.centeredSlides; if (l) { const e = a[0] / 2 - t.params.slidesOffsetBefore || 0; s.style.transform = `translateX(calc(50% - ${e}px))` } for (let s = 0; s < e.length; s += 1) { const a = e[s], o = a.progress, d = Math.min(Math.max(a.progress, -r.limitProgress), r.limitProgress); let c = d; l || (c = Math.min(Math.max(a.originalProgress, -r.limitProgress), r.limitProgress)); const p = a.swiperSlideOffset, u = [t.params.cssMode ? -p - t.translate : -p, 0, 0], m = [0, 0, 0]; let h = !1; t.isHorizontal() || (u[1] = u[0], u[0] = 0); let f = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; d < 0 ? (f = r.next, h = !0) : d > 0 && (f = r.prev, h = !0), u.forEach(((e, t) => { u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d * n)}))` })), m.forEach(((e, s) => { let a = f.rotate[s] * Math.abs(d * n); t.browser && t.browser.isSafari && Math.abs(a) / 90 % 2 == 1 && (a += .001), m[s] = a })), a.style.zIndex = -Math.abs(Math.round(o)) + e.length; const g = u.join(", "), v = `rotateX(${m[0]}deg) rotateY(${m[1]}deg) rotateZ(${m[2]}deg)`, w = c < 0 ? `scale(${1 + (1 - f.scale) * c * n})` : `scale(${1 - (1 - f.scale) * c * n})`, b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n, y = `translate3d(${g}) ${v} ${w}`; if (h && f.shadow || !h) { let e = a.querySelector(".swiper-slide-shadow"); if (!e && f.shadow && (e = dt("creative", a)), e) { const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d; e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const E = rt(r, a); E.style.transform = y, E.style.opacity = b, f.origin && (E.style.transformOrigin = f.origin) } }, n = e => { const s = t.slides.map((e => w(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), nt({ swiper: t, duration: e, transformElements: s, allSlides: !0 }) }; it({ effect: "creative", swiper: t, on: a, setTranslate: r, setTransition: n, perspective: () => t.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) }) } function mt(e) {
      let { swiper: t, extendParams: s, on: a } = e; s({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }); const i = () => {
        const { slides: e, activeIndex: s, rtlTranslate: a } = t, i = t.params.cardsEffect, { startTranslate: r, isTouched: n } = t.touchEventsData, l = a ? -t.translate : t.translate; for (let o = 0; o < e.length; o += 1) { const d = e[o], c = d.progress, p = Math.min(Math.max(c, -4), 4); let u = d.swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset); let m = t.params.cssMode ? -u - t.translate : -u, h = 0; const f = -100 * Math.abs(p); let g = 1, v = -i.perSlideRotate * p, w = i.perSlideOffset - .75 * Math.abs(p); const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o, y = (b === s || b === s - 1) && p > 0 && p < 1 && (n || t.params.cssMode) && l < r, E = (b === s || b === s + 1) && p < 0 && p > -1 && (n || t.params.cssMode) && l > r; if (y || E) { const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5; v += -28 * p * e, g += -.5 * e, w += 96 * e, h = -25 * e * Math.abs(p) + "%" } if (m = p < 0 ? `calc(${m}px ${a ? "-" : "+"} (${w * Math.abs(p)}%))` : p > 0 ? `calc(${m}px ${a ? "-" : "+"} (-${w * Math.abs(p)}%))` : `${m}px`, !t.isHorizontal()) { const e = h; h = m, m = e } const x = p < 0 ? "" + (1 + (1 - g) * p) : "" + (1 - (1 - g) * p), S = `\n        translate3d(${m}, ${h}, ${f}px)\n        rotateZ(${i.rotate ? a ? -v : v : 0}deg)\n        scale(${x})\n      `; if (i.slideShadows) { let e = d.querySelector(".swiper-slide-shadow"); e || (e = dt("cards", d)), e && (e.style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1)) } d.style.zIndex = -Math.abs(Math.round(c)) + e.length; rt(i, d).style.transform = S }
      }, r = e => { const s = t.slides.map((e => w(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), nt({ swiper: t, duration: e, transformElements: s }) }; it({ effect: "cards", swiper: t, on: a, setTranslate: i, setTransition: r, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) })
    } s.d(t, { Z: function () { return Lt } }); const ht = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }, ft = { document: ht, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; let gt, vt, wt; var bt = { on(e, t, s) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if ("function" != typeof t) return a; const i = s ? "unshift" : "push"; return e.split(" ").forEach((e => { a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t) })), a }, once(e, t, s) { function a() { i.off(e, a), a.__emitterProxy && delete a.__emitterProxy; for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++)r[n] = arguments[n]; t.apply(i, r) } const i = this; return !i.eventsListeners || i.destroyed || "function" != typeof t ? i : (a.__emitterProxy = t, i.on(e, a, s)) }, onAny(e, t) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof e) return s; const a = t ? "unshift" : "push"; return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const s = t.eventsAnyListeners.indexOf(e); return s >= 0 && t.eventsAnyListeners.splice(s, 1), t }, off(e, t) { const s = this; return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => { (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1) })) })), s) : s }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, s, a; for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++)r[n] = arguments[n]; "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a); return (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(a, [t, ...s]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(a, s) })) })), e } }; const yt = (e, t) => { if (!e || e.destroyed || !e.params) return; const s = () => e.isElement ? "swiper-slide" : `.${e.params.slideClass}`, a = t.closest(s()); if (a) { let t = a.querySelector(`.${e.params.lazyPreloaderClass}`); !t && e.isElement && (a.shadowRoot ? t = a.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((() => { a.shadowRoot && (t = a.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove()) }))), t && t.remove() } }, Et = (e, t) => { if (!e.slides[t]) return; const s = e.slides[t].querySelector('[loading="lazy"]'); s && s.removeAttribute("loading") }, xt = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const s = e.slides.length; if (!s || !t || t < 0) return; t = Math.min(t, s); const a = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), i = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const s = i, r = [s - t]; return r.push(...Array.from({ length: t }).map(((e, t) => s + a + t))), void e.slides.forEach(((t, s) => { r.includes(t.column) && Et(e, s) })) } const r = i + a - 1; if (e.params.rewind || e.params.loop) for (let a = i - t; a <= r + t; a += 1) { const t = (a % s + s) % s; (t < i || t > r) && Et(e, t) } else for (let a = Math.max(i - t, 0); a <= Math.min(r + t, s - 1); a += 1)a !== i && (a > r || a < i) && Et(e, a) }; const St = (e, t) => { const s = r(), { params: a, el: i, wrapperEl: n, device: l } = e, o = !!a.nested, d = "on" === t ? "addEventListener" : "removeEventListener", c = t; s[d]("touchstart", e.onDocumentTouchStart, { passive: !1, capture: o }), i[d]("touchstart", e.onTouchStart, { passive: !1 }), i[d]("pointerdown", e.onTouchStart, { passive: !1 }), s[d]("touchmove", e.onTouchMove, { passive: !1, capture: o }), s[d]("pointermove", e.onTouchMove, { passive: !1, capture: o }), s[d]("touchend", e.onTouchEnd, { passive: !0 }), s[d]("pointerup", e.onTouchEnd, { passive: !0 }), s[d]("pointercancel", e.onTouchEnd, { passive: !0 }), s[d]("touchcancel", e.onTouchEnd, { passive: !0 }), s[d]("pointerout", e.onTouchEnd, { passive: !0 }), s[d]("pointerleave", e.onTouchEnd, { passive: !0 }), s[d]("contextmenu", e.onTouchEnd, { passive: !0 }), (a.preventClicks || a.preventClicksPropagation) && i[d]("click", e.onClick, !0), a.cssMode && n[d]("scroll", e.onScroll), a.updateOnWindowResize ? e[c](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", ye, !0) : e[c]("observerUpdate", ye, !0), i[d]("load", e.onLoad, { capture: !0 }) }; const Tt = (e, t) => e.grid && t.grid && t.grid.rows > 1; var Mt = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; const Ct = { eventsEmitter: bt, update: { updateSize: H, updateSlides: N, updateAutoHeight: B, updateSlidesOffset: Y, updateSlidesProgress: R, updateProgress: V, updateSlidesClasses: q, updateActiveIndex: F, updateClickedSlide: j }, translate: { getTranslate: W, setTranslate: U, minTranslate: K, maxTranslate: Z, translateTo: Q }, transition: { setTransition: J, transitionStart: te, transitionEnd: se }, slide: { slideTo: ae, slideToLoop: ie, slideNext: re, slidePrev: ne, slideReset: le, slideToClosest: oe, slideToClickedSlide: de }, loop: { loopCreate: ce, loopFix: pe, loopDestroy: ue }, grabCursor: { setGrabCursor: me, unsetGrabCursor: he }, events: { attachEvents: Me, detachEvents: Ce }, breakpoints: { setBreakpoint: Pe, getBreakpoint: Le }, checkOverflow: { checkOverflow: ze }, classes: { addClasses: Ie, removeClasses: ke } }, Pt = {}; class Lt { constructor() { let e, t; for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++)a[i] = arguments[i]; 1 === a.length && a[0].constructor && "Object" === Object.prototype.toString.call(a[0]).slice(8, -1) ? t = a[0] : [e, t] = a, t || (t = {}), t = f({}, t), e && !t.el && (t.el = e); const n = r(); if (t.el && "string" == typeof t.el && n.querySelectorAll(t.el).length > 1) { const e = []; return n.querySelectorAll(t.el).forEach((s => { const a = f({}, t, { el: s }); e.push(new Lt(a)) })), e } const l = this; l.__swiper__ = !0, l.support = k(), l.device = $({ userAgent: t.userAgent }), l.browser = D(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules); const o = {}; l.modules.forEach((e => { e({ params: t, swiper: l, extendParams: $e(t, o), on: l.on.bind(l), once: l.once.bind(l), off: l.off.bind(l), emit: l.emit.bind(l) }) })); const d = f({}, Mt, o); return l.params = f({}, d, Pt, t), l.originalParams = f({}, l.params), l.passedParams = f({}, t), l.params && l.params.on && Object.keys(l.params.on).forEach((e => { l.on(e, l.params.on[e]) })), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, { enabled: l.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === l.params.direction, isVertical: () => "vertical" === l.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: l.params.allowSlideNext, allowSlidePrev: l.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: l.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: l.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), l.emit("_swiper"), l.params.init && l.init(), l } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: t, params: s } = this, a = C(b(t, `.${s.slideClass}, swiper-slide`)[0]); return C(e) - a } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0]) } recalcSlides() { const e = this, { slidesEl: t, params: s } = e; e.slides = b(t, `.${s.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const s = this; e = Math.min(Math.max(e, 0), 1); const a = s.minTranslate(), i = (s.maxTranslate() - a) * e + a; s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach((s => { const a = e.getSlideClasses(s); t.push({ slideEl: s, classNames: a }), e.emit("_slideClass", s, a) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const s = this, { params: a, slides: i, slidesGrid: r, slidesSizesGrid: n, size: l, activeIndex: o } = s; let d = 1; if ("number" == typeof a.slidesPerView) return a.slidesPerView; if (a.centeredSlides) { let e, t = i[o] ? i[o].swiperSlideSize : 0; for (let s = o + 1; s < i.length; s += 1)i[s] && !e && (t += i[s].swiperSlideSize, d += 1, t > l && (e = !0)); for (let s = o - 1; s >= 0; s -= 1)i[s] && !e && (t += i[s].swiperSlideSize, d += 1, t > l && (e = !0)) } else if ("current" === e) for (let e = o + 1; e < i.length; e += 1) { (t ? r[e] + n[e] - r[o] < l : r[e] - r[o] < l) && (d += 1) } else for (let e = o - 1; e >= 0; e -= 1) { r[o] - r[e] < l && (d += 1) } return d } update() { function e() { const e = t.rtlTranslate ? -1 * t.translate : t.translate, s = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate()); t.setTranslate(s), t.updateActiveIndex(), t.updateSlidesClasses() } const t = this; if (!t || t.destroyed) return; const { snapGrid: s, params: a } = t; let i; if (a.breakpoints && t.setBreakpoint(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e => { e.complete && yt(t, e) })), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), a.freeMode && a.freeMode.enabled && !a.cssMode) e(), a.autoHeight && t.updateAutoHeight(); else { if (("auto" === a.slidesPerView || a.slidesPerView > 1) && t.isEnd && !a.centeredSlides) { const e = t.virtual && a.virtual.enabled ? t.virtual.slides : t.slides; i = t.slideTo(e.length - 1, 0, !1, !0) } else i = t.slideTo(t.activeIndex, 0, !1, !0); i || e() } a.watchOverflow && s !== t.snapGrid && t.checkOverflow(), t.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); const s = this, a = s.params.direction; return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${a}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), s.emit("changeDirection"), t && s.update()), s } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let s = e || t.params.el; if ("string" == typeof s && (s = document.querySelector(s)), !s) return !1; s.swiper = t, s.parentNode && s.parentNode.host && "SWIPER-CONTAINER" === s.parentNode.host.nodeName && (t.isElement = !0); const a = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let i = (() => { if (s && s.shadowRoot && s.shadowRoot.querySelector) { return s.shadowRoot.querySelector(a()) } return b(s, a())[0] })(); return !i && t.params.createElements && (i = E("div", t.params.wrapperClass), s.append(i), b(s, `.${t.params.slideClass}`).forEach((e => { i.append(e) }))), Object.assign(t, { el: s, wrapperEl: i, slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : i, hostEl: t.isElement ? s.parentNode.host : s, mounted: !0, rtl: "rtl" === s.dir.toLowerCase() || "rtl" === M(s, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === M(s, "direction")), wrongRTL: "-webkit-box" === M(i, "display") }), !0 } init(e) { const t = this; if (t.initialized) return t; if (!1 === t.mount(e)) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const s = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach((e => { e.complete ? yt(t, e) : e.addEventListener("load", (e => { yt(t, e.target) })) })), xt(t), t.initialized = !0, xt(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const s = this, { params: a, el: i, wrapperEl: r, slides: n } = s; return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttribute("style"), r.removeAttribute("style"), n && n.length && n.forEach((e => { e.classList.remove(a.slideVisibleClass, a.slideFullyVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") }))), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => { s.off(e) })), !1 !== e && (s.el.swiper = null, o(s)), s.destroyed = !0), null } static extendDefaults(e) { f(Pt, e) } static get extendedDefaults() { return Pt } static get defaults() { return Mt } static installModule(e) { Lt.prototype.__modules__ || (Lt.prototype.__modules__ = []); const t = Lt.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => Lt.installModule(e))), Lt) : (Lt.installModule(e), Lt) } } Object.keys(Ct).forEach((e => { Object.keys(Ct[e]).forEach((t => { Lt.prototype[t] = Ct[e][t] })) })), Lt.use([G, X]); const At = [Oe, De, Ge, He, Be, Ye, Re, Ve, qe, _e, Fe, je, We, Ue, Ke, Ze, at, lt, ot, ct, pt, ut, mt]; Lt.use(At)
  }
}, function (e) { t = 80316, e(e.s = t); var t }]);